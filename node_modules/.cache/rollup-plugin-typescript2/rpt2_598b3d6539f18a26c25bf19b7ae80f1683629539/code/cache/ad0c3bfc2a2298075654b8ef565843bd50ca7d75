{"code":"/**公共方法 */\n// 判断是否为对象\nexport const isObject = (target) => typeof target === \"object\" && target !== null; //因为 typeof null 也是 \"object\"，需要排除它。\nexport const isArray = Array.isArray;\nexport const isFunction = (val) => typeof val === \"function\";\nexport const isString = (val) => typeof val === \"string\";\nexport const isNumber = (val) => typeof val === \"number\";\n// 合并两个对象\nexport const extend = Object.assign; //直接将 ES 的 Object.assign() 方法赋值为 extend 名称\n// 判断对象是否有某个属性（两个参数，返回值为布尔型，key is keyof typeof val使用了ts的类型守卫语法）\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n//下面这个函数；函数名是hasOwn，参数是val和key，): key is keyof typeof val =>是箭头函数的返回类型注解；真正的函数体是箭头后面的\nexport const hasOwn = (val, key //第二个参数叫key，可以是字符串或Symbol类型\n) => hasOwnProperty.call(val, key);\n//typeof val：获取变量 val 的类型，相当于：name:string;age:number\n//keyof typeof val:表示这个对象类型的所有“键名”组成的联合类型：type KeyType = \"name\" | \"age\";\n//总体意思:如果函数返回true,那我保证这个key就是val对象的一个有效键\n//这里的.call()作用是改变函数执行时候的this指向\n//例子：const obj = Object.create(null)\n//obj.name = '李四'\n//obj.hasOwnProperty('name') // ❌ 报错！\n//Object.prototype.hasOwnProperty.call(obj, 'name') // ✅ true\n// 判断数组的key是否是整数\n// 数组经过proxy代理之后，会变成对象的形式，如console.log(new Proxy([1,2,3],{})); ===》Proxy(Array) {'0': 1, '1': 2, '2': 3}（js对象的key类型为字符串），因此\"\" + parseInt(key, 10)这样是为了方便拿到正确的字符串key用于判断\n// console.log(Array.isArray(new Proxy([1,2,3],{})))===》true\n// 比如此时arr[2]=4，应该是\nexport const isIntegerKey = (key) => {\n    isString(key) &&\n        key !== \"NaN\" &&\n        key[0] !== \"-\" &&\n        \"\" + parseInt(key, 10) === key; //只有当 key 是纯数字字符串，并且没有多余字符（如前导零、单位 px、字母等）时，这个表达式才为 true。\n    //parseInt(key, 10)：把 key 转换为整数（忽略后面非数字字符）。\n    //\"\" + ...：把解析出来的数字 转成字符串。\n    //\"\" + parseInt(key, 10)即(比如\"08\"->8->\"8\")\n};\n// 判断值是否更新\nexport const hasChange = (value, oldValue) => value !== oldValue;\n//# sourceMappingURL=general.js.map","references":[],"map":"{\"version\":3,\"file\":\"general.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../packages/shared/src/general.ts\"],\"names\":[],\"mappings\":\"AAAA,UAAU;AACV,UAAU;AACV,MAAM,CAAC,MAAM,QAAQ,GAAG,CAAC,MAAM,EAAE,EAAE,CAC/B,OAAO,MAAM,KAAK,QAAQ,IAAI,MAAM,KAAK,IAAI,CAAC,CAAA,mCAAmC;AACrF,MAAM,CAAC,MAAM,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC;AACrC,MAAM,CAAC,MAAM,UAAU,GAAG,CAAC,GAAG,EAAE,EAAE,CAAC,OAAO,GAAG,KAAK,UAAU,CAAC;AAC7D,MAAM,CAAC,MAAM,QAAQ,GAAG,CAAC,GAAG,EAAE,EAAE,CAAC,OAAO,GAAG,KAAK,QAAQ,CAAC;AACzD,MAAM,CAAC,MAAM,QAAQ,GAAG,CAAC,GAAG,EAAE,EAAE,CAAC,OAAO,GAAG,KAAK,QAAQ,CAAC;AACzD,SAAS;AACT,MAAM,CAAC,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,CAAA,0CAA0C;AAE9E,gEAAgE;AAChE,MAAM,cAAc,GAAG,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC;AACvD,qFAAqF;AACrF,MAAM,CAAC,MAAM,MAAM,GAAG,CACpB,GAAW,EACX,GAAoB,CAAC,2BAA2B;EACvB,EAAE,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,EAAC,GAAG,CAAC,CAAC;AAC3D,oDAAoD;AACpD,wEAAwE;AACxE,wCAAwC;AACxC,8BAA8B;AAC5B,oCAAoC;AAC9B,iBAAiB;AACjB,qCAAqC;AACrC,6DAA6D;AAGrE,gBAAgB;AAChB,uKAAuK;AACvK,4DAA4D;AAC5D,mBAAmB;AACnB,MAAM,CAAC,MAAM,YAAY,GAAG,CAAC,GAAG,EAAE,EAAE;IAClC,QAAQ,CAAC,GAAG,CAAC;QACX,GAAG,KAAK,KAAK;QACb,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG;QACd,EAAE,GAAG,QAAQ,CAAC,GAAG,EAAE,EAAE,CAAC,KAAK,GAAG,CAAC,CAAA,yDAAyD;IACxF,2CAA2C;IAC3C,0BAA0B;IAC1B,yCAAyC;AAC7C,CAAC,CAAC;AAEF,UAAU;AACV,MAAM,CAAC,MAAM,SAAS,GAAG,CAAC,KAAK,EAAE,QAAQ,EAAE,EAAE,CAAC,KAAK,KAAK,QAAQ,CAAC\"}","dts":{"name":"D:/mini-vue-main/weak-vue/node_modules/.cache/rollup-plugin-typescript2/placeholder/shared/src/general.d.ts","writeByteOrderMark":false,"text":"/**公共方法 */\nexport declare const isObject: (target: any) => boolean;\nexport declare const isArray: (arg: any) => arg is any[];\nexport declare const isFunction: (val: any) => boolean;\nexport declare const isString: (val: any) => val is string;\nexport declare const isNumber: (val: any) => val is number;\nexport declare const extend: {\n    <T extends {}, U>(target: T, source: U): T & U;\n    <T extends {}, U, V>(target: T, source1: U, source2: V): T & U & V;\n    <T extends {}, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W;\n    (target: object, ...sources: any[]): any;\n};\nexport declare const hasOwn: (val: object, key: string | symbol) => key is keyof typeof val;\nexport declare const isIntegerKey: (key: any) => void;\nexport declare const hasChange: (value: any, oldValue: any) => boolean;\n"}}

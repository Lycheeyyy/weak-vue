{"code":"import { isFunction, isObject, ShapeFlags } from \"@vue/shared\";\nimport { componentPublicInstance } from \"./componentPublicInstance\";\n// 创建组件实例\nexport const createComponentInstance = (vnode) => {\n    // instance本质是一个对象(包含组件的vnode，前面实现的组件的一些属性如参数props、自定义属性attrs，setup入口函数的状态等)\n    const instance = {\n        vnode,\n        type: vnode.type, // 组件的所有属性都在这里面\n        props: {}, // 组件的参数\n        attrs: {}, // 自定义属性\n        setupState: {}, // 用来存储setup入口函数的返回值\n        //ctx是渲染上下文\n        ctx: {}, // 用来处理代理，保存实例的值，和下面的proxy一起用。没有这个会导致用类似instance.props.xxx才能获取属性，有了之后直接proxy.xxx便能直接获取了\n        proxy: {}, // 和上面的ctx一起用\n        render: false, // 存储组件实例的渲染函数\n        isMounted: false, // 是否挂载\n    };\n    //这个语句的重点是：给 instance.ctx 赋一个对象，这个对象里有一个键 _，它的值是 instance 本身。\n    instance.ctx = { _: instance }; //是一个 Vue 内部的约定写法，表示 “这个上下文来自哪个组件实例”\n    return instance;\n};\n// 解析数据到该组件实例\nexport const setupComponet = (instance) => {\n    // 代理\n    instance.proxy = new Proxy(instance.ctx, componentPublicInstance);\n    // 拿到值（上面instance的props等）\n    const { props, children } = instance.vnode;\n    // 把值设置到组件实例上\n    instance.props = props;\n    instance.children = children; // 相当于slot插槽\n    // 看一下这个组件有无状态（有状态代表有setup入口函数或者render函数）\n    const shapeFlag = instance.vnode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT;\n    if (shapeFlag) {\n        setupStateComponent(instance);\n    }\n    else {\n        // 如果无状态，说明是简单组件，直接渲染即可。\n    }\n};\n// 处理有状态的组件\nfunction setupStateComponent(instance) {\n    // setup方法的返回值是我们的render函数的参数\n    // 拿到组件的setup方法\n    //   其中我们可以知道：\n    // 1、setup方法的参数是组件参数props、上下文对象context（包含了父组件传递下来的非 prop 属性attrs、可以用来触发父组件中绑定的事件函数emit、一个指向当前组件实例的引用root、用来获取插槽内容的函数slot等）\n    // 2、setup方法的返回值可以是一个对象（包含代理的响应式属性以供渲染函数使用），也可以是直接返回渲染函数\n    const Component = instance.type; // createVNode时传入给type的是rootComponent，本质是一个对象，组件的所有属性都在这里，比如setup方法，比如render方法\n    const { setup } = Component;\n    //处理参数\n    //const setupContext = createContext(instance); // 返回一个上下文对象\n    //setup(instance.props, setupContext); // 实际执行的setup函数（实参）\n    //instance.proxy = new Proxy(instance.ctx, componentPublicInstance as any);\n    if (setup) {\n        const setupContext = createContext(instance); // 返回一个上下文对象\n        //调用组件定义中的 setup 函数，传入 props 和上下文\n        const setupResult = setup(instance.props, setupContext); // 实际执行的setup函数（实参）\n        // setup返回值有两种情况：1、对象；2、函数==>根据不同情况进行处理\n        // 如果是对象，则将值放在instance.setupState；如果是函数，则就是render函数\n        handlerSetupResult(instance, setupResult);\n    }\n    else {\n        // 没有setup则会有instance.type.render方法的（处理无setup有render的情况）\n        finishComponentSetup(instance); // 通过vnode拿到render方法\n    }\n}\n// 处理context上下文对象（包含了父组件传递下来的非 prop 属性attrs、可以用来触发父组件中绑定的事件函数emit、一个指向当前组件实例的引用root、用来获取插槽内容的函数slot等）\nfunction createContext(instance) {\n    return {\n        sttrs: instance.attrs,\n        slots: instance.slots,\n        emit: () => { },\n        expose: () => { },\n    };\n}\n// 处理setup函数的返回结果\nfunction handlerSetupResult(instance, setupResult) {\n    if (isFunction(setupResult)) {\n        instance.render = setupResult; // 处理有setup且返回函数的情况==>没必要使用组件的render方法了\n    }\n    else if (isObject(setupResult)) {\n        //setupState是vue组件实例instance中用于存储setup()返回对象中的状态的属性\n        instance.setupState = setupResult; // 处理有setup且返回对象的情况==>要使用组件的render方法了\n    }\n    // 最终也会走render（把render挂载到实例上去）\n    finishComponentSetup(instance);\n}\n// 处理render（把render挂载到实例上去）\nfunction finishComponentSetup(instance) {\n    // 判断组件中有没有render方法，没有则\n    const Component = instance.type; // createVNode时传入给type的是rootComponent，本质是一个对象，组件的所有属性都在这里，比如setup方法，比如render方法\n    if (!instance.render) {\n        // 这里的render指的是上面instance实例的render属性，在handlerSetupResult函数中会赋值（赋值的情况：组件有setup且返回函数），如果没有setup则此时会为false，则需要赋组件的render方法\n        //template 是 HTML 字符串。Vue 会用它的模板编译器（@vue/compiler-dom）把它编译成 JS 渲染函数。\n        if (!Component.render && Component.template) {\n            // TODO：模版编译\n        }\n        instance.render = Component.render;\n    }\n    //console.log(instance.render);\n}\n//# sourceMappingURL=component.js.map","references":["D:/mini-vue-main/weak-vue/node_modules/.pnpm/@vue+shared@3.5.14/node_modules/@vue/shared/dist/shared.d.ts","D:/mini-vue-main/weak-vue/packages/runtime-core/src/componentPublicInstance.ts"],"map":"{\"version\":3,\"file\":\"component.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../packages/runtime-core/src/component.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,EAAU,UAAU,EAAE,QAAQ,EAAE,UAAU,EAAE,MAAM,aAAa,CAAC;AACvE,OAAO,EAAE,uBAAuB,EAAE,MAAM,2BAA2B,CAAC;AAEpE,SAAS;AACT,MAAM,CAAC,MAAM,uBAAuB,GAAG,CAAC,KAAK,EAAE,EAAE;IACjD,4EAA4E;IAC5E,MAAM,QAAQ,GAAG;QACf,KAAK;QACL,IAAI,EAAE,KAAK,CAAC,IAAI,EAAE,eAAe;QACjC,KAAK,EAAE,EAAE,EAAE,QAAQ;QACnB,KAAK,EAAE,EAAE,EAAE,QAAQ;QACnB,UAAU,EAAE,EAAE,EAAE,oBAAoB;QACpC,WAAW;QACX,GAAG,EAAE,EAAE,EAAE,uFAAuF;QAChG,KAAK,EAAE,EAAE,EAAE,aAAa;QACxB,MAAM,EAAE,KAAK,EAAE,cAAc;QAC7B,SAAS,EAAE,KAAK,EAAE,OAAO;KAC1B,CAAC;IACF,6DAA6D;IAC7D,QAAQ,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,QAAQ,EAAE,CAAC,CAAA,oCAAoC;IACnE,OAAO,QAAQ,CAAC;AAChB,CAAC,CAAC;AAEF,aAAa;AACb,MAAM,CAAC,MAAM,aAAa,GAAG,CAAC,QAAQ,EAAE,EAAE;IACxC,KAAK;IACL,QAAQ,CAAC,KAAK,GAAG,IAAI,KAAK,CAAC,QAAQ,CAAC,GAAG,EAAE,uBAA8B,CAAC,CAAC;IAEzE,yBAAyB;IACzB,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,GAAG,QAAQ,CAAC,KAAK,CAAC;IAC3C,aAAa;IACb,QAAQ,CAAC,KAAK,GAAG,KAAK,CAAC;IACvB,QAAQ,CAAC,QAAQ,GAAG,QAAQ,CAAC,CAAC,YAAY;IAC1C,yCAAyC;IACzC,MAAM,SAAS,GAAG,QAAQ,CAAC,KAAK,CAAC,SAAS,GAAG,UAAU,CAAC,kBAAkB,CAAC;IAC3E,IAAI,SAAS,EAAE,CAAC;QACd,mBAAmB,CAAC,QAAQ,CAAC,CAAC;IAChC,CAAC;SAAM,CAAC;QACN,wBAAwB;IAC1B,CAAC;AACH,CAAC,CAAC;AAGF,WAAW;AACX,SAAS,mBAAmB,CAAC,QAAQ;IACjC,6BAA6B;IAC7B,eAAe;IACf,cAAc;IACd,0HAA0H;IAC1H,wDAAwD;IACxD,MAAM,SAAS,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC,8EAA8E;IAC/G,MAAM,EAAE,KAAK,EAAE,GAAG,SAAS,CAAC;IAC5B,MAAM;IACN,4DAA4D;IAC5D,0DAA0D;IAE1D,2EAA2E;IAE3E,IAAI,KAAK,EAAE,CAAC;QACR,MAAM,YAAY,GAAG,aAAa,CAAC,QAAQ,CAAC,CAAC,CAAC,YAAY;QAC1D,iCAAiC;QACjC,MAAM,WAAW,GAAG,KAAK,CAAC,QAAQ,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC,CAAC,mBAAmB;QAC5E,uCAAuC;QACvC,mDAAmD;QACnD,kBAAkB,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;IAC5C,CAAC;SAAM,CAAC;QACN,wDAAwD;QACxD,oBAAoB,CAAC,QAAQ,CAAC,CAAC,CAAC,oBAAoB;IACtD,CAAC;AAEP,CAAC;AAGD,qGAAqG;AACrG,SAAS,aAAa,CAAC,QAAQ;IAC7B,OAAO;QACL,KAAK,EAAE,QAAQ,CAAC,KAAK;QACrB,KAAK,EAAE,QAAQ,CAAC,KAAK;QACrB,IAAI,EAAE,GAAG,EAAE,GAAE,CAAC;QACd,MAAM,EAAE,GAAG,EAAE,GAAE,CAAC;KACjB,CAAC;AACJ,CAAC;AAED,iBAAiB;AACjB,SAAS,kBAAkB,CAAC,QAAQ,EAAE,WAAW;IAC7C,IAAI,UAAU,CAAC,WAAW,CAAC,EAAE,CAAC;QAC5B,QAAQ,CAAC,MAAM,GAAG,WAAW,CAAC,CAAC,uCAAuC;IACxE,CAAC;SAAM,IAAI,QAAQ,CAAC,WAAW,CAAC,EAAE,CAAC;QAC/B,mDAAmD;QACrD,QAAQ,CAAC,UAAU,GAAG,WAAW,CAAC,CAAC,qCAAqC;IAC1E,CAAC;IAED,8BAA8B;IAC9B,oBAAoB,CAAC,QAAQ,CAAC,CAAC;AACjC,CAAC;AAEH,2BAA2B;AAC3B,SAAS,oBAAoB,CAAC,QAAQ;IAClC,uBAAuB;IACvB,MAAM,SAAS,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC,8EAA8E;IAC/G,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC;QACrB,uHAAuH;QACvH,oEAAoE;QACpE,IAAI,CAAC,SAAS,CAAC,MAAM,IAAI,SAAS,CAAC,QAAQ,EAAE,CAAC;YAC5C,YAAY;QACd,CAAC;QACD,QAAQ,CAAC,MAAM,GAAG,SAAS,CAAC,MAAM,CAAC;IACrC,CAAC;IACD,+BAA+B;AACjC,CAAC\"}","dts":{"name":"D:/mini-vue-main/weak-vue/node_modules/.cache/rollup-plugin-typescript2/placeholder/runtime-core/src/component.d.ts","writeByteOrderMark":false,"text":"export declare const createComponentInstance: (vnode: any) => {\n    vnode: any;\n    type: any;\n    props: {};\n    attrs: {};\n    setupState: {};\n    ctx: {};\n    proxy: {};\n    render: boolean;\n    isMounted: boolean;\n};\nexport declare const setupComponet: (instance: any) => void;\n"}}

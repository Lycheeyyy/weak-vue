{"code":"//import { ShapeFlags } from \"@vue/shared\";\n//import { effect } from \"@vue/reactivity\";\n//import { apiCreateApp } from \"./apiCreateApp\";\n//import { createComponentInstance, setupComponet } from \"./component\";\n//\n//  // 实现渲染Vue3组件==>vnode==>render\n//export function createRender(renderOptionDom) {\n//\n//  const processComponent = (n1, n2, container) => {//负责处理组件的渲染（初次渲染和更新两种情况）\n//    if (n1 === null) {\n//      // 组件第一次加载\n//      mountComponent(n2, container);\n//    } else {\n//      // 更新\n//    }\n//  };\n//\n//  // 组件渲染的真正方法（实现由虚拟dom变成真实dom），步骤（核心）：\n//const mountComponent = (InitialVnode, container) => {\n//  //InitialVnode是当前要挂载的虚拟节点\n//  // 1、先有一个组件的实例对象（即Vue3组件渲染函数render传入的第一个参数proxy，其实proxy参数将组件定义的所有属性合并了，等效于在setup入口函数里面返回一个函数，可以用proxy.来获取属性）\n//  const instanece = (InitialVnode.component =//InitialVnode.component是指当前组件虚拟节点所关联的组件实例对象\n//    //createComponentInstance会基于当前虚拟节点 InitialVnode 创建一个组件实例对象（包含 props、setup 返回值、render 函数等）\n//    createComponentInstance(InitialVnode)); // 记得在weak-vue\\packages\\runtime-core\\src\\vnode.ts文件给vnode定义中加上这个属性\n//    //↑vnode.component 本来是 null，你需要手动创建一个组件实例对象并挂载回 vnode.component，\n//  // 2、解析数据到这个实例对象中\n//  setupComponet(instanece);\n//  // 3、创建一个effect让render函数执行\n//  setupRenderEffect(instanece);\n//};\n//\n//// 创建一个effect让render函数执行(响应式)\n//function setupRenderEffect(instance) {\n//  // 创建effect(原理可以回前面的内容找)\n//  //effect作用： 收集副作用函数，当依赖的数据发生变化时，这个副作用函数就会重新执行。\n//  //componentEffect() 是副作用函数，也就是渲染函数。每次响应式数据变了，它都会重新调用。\n//  effect(function componentEffect() {\n//    // 判断是否是初次渲染\n//    if (!instance.isMounted) {//isMounted是一个标志属性，用来 标识当前组件是否已经挂载过（即是否是第一次渲染）。\n//      // 获取到render返回值\n//      const proxy = instance.proxy; // 已经代理了组件，可以访问到组件的所有属性和所有方法\n//      //.call(proxy, proxy) 的意思是：用 proxy 来作为 this，也作为参数传进去。这样写可以确保在 render 函数中可以写成 this.xxx 或直接访问 proxy.xxx。\n//      // render函数执行，即调用render函数，第一个参数表示render函数的this指向组件实例proxy，第二个参数表示执行render函数的参数也是proxy\n//    \n//      const subTree = instance.render.call(proxy, proxy);\n//      console.log(\"h函数生成的vnode树：\", subTree);\n//    }\n//\n//  });\n//}\n//\n//\n//  \n//  // patch函数负责根据vnode的不同情况（组件、元素）来实现对应的渲染\n//const patch = (n1, n2, container) => {\n//  // 针对不同的类型采取不同的渲染方式（vnode有一个shapeFlag标识来标识组件/元素）\n//  const { shapeFlag } = n2;\n//  // 等效于shapeFlag && shapeFlag === ShapeFlags.ELEMENT\n//  //因为一个vnode可以有多个类型，比如是元素，又有子元素，不能只用===判断唯一性，要用位运算表示多个特征\n//  //按位与:两个数的对应位都为 1，结果才是 1，否则就是 0\n//  if (shapeFlag & ShapeFlags.ELEMENT) {//判断 shapeFlag 是否包含 ShapeFlags.ELEMENT 这个标志。它返回一个数字，若结果不为 0，则说明包含。\n//    // 处理元素\n//    // console.log(\"元素\");\n//  } else if (shapeFlag & ShapeFlags.STATEFUL_COMPONENT) {\n//    // 处理组件\n//    processComponent(n1, n2, container);\n//  }\n//};\n//  // 真正实现渲染的函数（渲染vnode)\n//  let render = (vnode, container) => {\n//        // 第一次渲染（三个参数：旧的节点、当前节点、位置）\n//        patch(null, vnode, container);\n//  };\n//\n///** ---------------处理元素--------------- */\n//const processElement = (n1, n2, container) => {\n//  if (n1 === null) {\n//    // 元素第一次挂载\n//    mountElement(n2, container);\n//  } else {\n//    // 更新\n//  }\n//};\n//\n//const mountElement = (vnode, container) => {\n//  // 递归渲染子节点==>dom操作==》挂载到container/页面上\n//  const { shapeFlag, props, type, children } = vnode;\n//  // 1、创建元素--记得把真实dom挂载到vnode上，方便后面更新时使用\n//  let el = (vnode.el = hostCreateElement(type));\n//  // 2、创建元素的属性\n//  if (props) {\n//    for (const key in props) {\n//      hostPatchProp(el, key, null, props[key]);\n//    }\n//  }\n//  // 3、放入到对应的容器中\n//  hostInsert(el, container);\n//};\n//\n//\n//\n//\n//  // 返回一个具有createApp方法的对象，其中createApp负责生成一个具有mount挂载方法的app对象（包含属性、方法等），进而实现1、生成vnode；2、render渲染vnode\n//  return {\n//    createApp: apiCreateApp(render),\n//  };\n//\n//}\n//\n//\n//\nimport { ShapeFlags } from \"@vue/shared\";\nimport { effect } from \"@vue/reactivity\";\nimport { apiCreateApp } from \"./apiCreateApp\";\nimport { createComponentInstance, setupComponet } from \"./component\";\nimport { CVnode, TEXT } from \"./vnode\";\n// 实现渲染Vue3组件==>vnode==>render\nexport function createRender(renderOptionDom) {\n    // 获取所有的dom操作\n    const { insert: hostInsert, remove: hostRemove, patchProps: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, } = renderOptionDom;\n    // 创建一个effect让render函数执行(响应式)\n    const setupRenderEffect = (instance, container) => {\n        // 创建effect(原理可以回前面的内容找)\n        effect(function componentEffect() {\n            // 判断是否是初次渲染\n            if (!instance.isMounted) {\n                // 获取到render返回值\n                const proxy = instance.proxy; // 已经代理了组件，可以访问到组件的所有属性和所有方法\n                // console.log(\"这是组件实例proxy：\");\n                // console.log(proxy);\n                const subTree = instance.render.call(proxy, proxy); // render函数执行，即调用render函数，第一个参数表示render函数的this指向组件实例proxy，第二个参数表示执行render函数的参数也是proxy\n                // console.log(\"h函数生成的vnode树：\", subTree);\n                patch(null, subTree, container); // 渲染vnode（此时是元素的vnode）\n            }\n        });\n    };\n    /** ---------------处理组件--------------- */\n    // 组件的创建方法（分为初次渲染和更新两种情况）\n    const processComponent = (n1, n2, container) => {\n        if (n1 === null) {\n            // 组件第一次加载\n            mountComponent(n2, container);\n        }\n        else {\n            // 更新\n        }\n    };\n    // 组件渲染的真正方法（实现由虚拟dom变成真实dom），步骤（核心）：\n    const mountComponent = (InitialVnode, container) => {\n        // 1、先有一个组件的实例对象（即Vue3组件渲染函数render传入的第一个参数proxy，其实proxy参数将组件定义的所有属性合并了，等效于在setup入口函数里面返回一个函数，可以用proxy.来获取属性）\n        const instanece = (InitialVnode.component =\n            createComponentInstance(InitialVnode)); // 记得在Vue3.0\\packages\\runtime-core\\src\\vnode.ts文件给vnode定义中加上这个属性\n        // 2、解析数据到这个实例对象中\n        setupComponet(instanece);\n        // 3、创建一个effect让render函数执行\n        setupRenderEffect(instanece, container);\n    };\n    /** ---------------处理元素--------------- */\n    const processElement = (n1, n2, container) => {\n        if (n1 === null) {\n            // 元素第一次挂载\n            mountElement(n2, container);\n        }\n        else {\n            // 更新\n        }\n    };\n    // 元素的渲染方法\n    const mountElement = (vnode, container) => {\n        // 递归渲染子节点==>dom操作==》挂载到container/页面上\n        const { shapeFlag, props, type, children } = vnode;\n        // 1、创建元素\n        let el = hostCreateElement(type);\n        // 2、创建元素的属性\n        if (props) {\n            for (const key in props) {\n                hostPatchProp(el, key, null, props[key]);\n            }\n        }\n        // 3、处理children\n        if (children) {\n            if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\n                console.log(\"这是文本字符串形式子节点：\", children);\n                hostSetElementText(el, children); // 文本形式子节点，比如这种情况：h('div',{},'张三')，将children直接插入到el中\n            }\n            else if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n                // 递归渲染子节点\n                console.log(\"这是数组形式子节点：\", children);\n                mountChildren(el, children); // 数组形式子节点，比如这种情况：h('div',{},['张三',h('p',{},'李四')])，将children递归渲染插入到el中\n            }\n        }\n        // 4、放入到对应的容器中\n        hostInsert(el, container);\n    };\n    // 递归渲染子节点\n    const mountChildren = (container, children) => {\n        for (let i = 0; i < children.length; i++) {\n            // children[i]两种情况：1、['张三']这种元素，字符串的形式；2、h('div',{},'张三')这种元素，对象的形式（vnode）\n            // 但两种情况都需要转换成vnode来处理，方便借助patch函数来渲染\n            const child = CVnode(children[i]); // 第一种情况转换成vnode\n            // 递归渲染子节点（vnode包含了元素、组件、文本三种情况）\n            patch(null, child, container);\n        }\n    };\n    /** ---------------处理文本--------------- */\n    const processTxt = (n1, n2, container) => {\n        if (n1 === null) {\n            // 创建文本==>直接渲染到页面中（变成真实dom==>插入）\n            hostInsert(hostCreateText(n2.children), container);\n        }\n        else {\n            // 更新\n        }\n    };\n    /**---------------------------------------------------------- */\n    // patch函数负责根据vnode的不同情况（组件、元素、文本）来实现对应的渲染\n    const patch = (n1, n2, container) => {\n        // 针对不同的类型采取不同的渲染方式（vonode有一个shapeFlag标识来标识组件/元素）\n        const { shapeFlag, type } = n2;\n        switch (type) {\n            case TEXT:\n                // 处理文本\n                processTxt(n1, n2, container);\n                break;\n            default:\n                // 等效于shapeFlag && shapeFlag === ShapeFlags.ELEMENT\n                if (shapeFlag & ShapeFlags.ELEMENT) {\n                    // 处理元素(h函数)\n                    // console.log(\"此时处理的是元素！！！\");\n                    processElement(n1, n2, container);\n                }\n                else if (shapeFlag & ShapeFlags.STATEFUL_COMPONENT) {\n                    // 处理组件\n                    processComponent(n1, n2, container);\n                }\n        }\n    };\n    // 真正实现渲染的函数（渲染vnode)\n    const render = (vnode, container) => {\n        // 第一次渲染（三个参数：旧的节点、当前节点、位置）\n        patch(null, vnode, container);\n    };\n    // 返回一个具有createApp方法的对象，其中createApp负责生成一个具有mount挂载方法的app对象（包含属性、方法等），进而实现1、生成vnode；2、render渲染vnode\n    return {\n        createApp: apiCreateApp(render),\n    };\n}\n//# sourceMappingURL=render.js.map","references":["D:/mini-vue-main/weak-vue/node_modules/.pnpm/@vue+shared@3.5.14/node_modules/@vue/shared/dist/shared.d.ts","D:/mini-vue-main/weak-vue/node_modules/.pnpm/@vue+reactivity@3.5.14/node_modules/@vue/reactivity/dist/reactivity.d.ts","D:/mini-vue-main/weak-vue/packages/runtime-core/src/apiCreateApp.ts","D:/mini-vue-main/weak-vue/packages/runtime-core/src/component.ts","D:/mini-vue-main/weak-vue/packages/runtime-core/src/vnode.ts"],"map":"{\"version\":3,\"file\":\"render.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../packages/runtime-core/src/render.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"D:/mini-vue-main/weak-vue/node_modules/.cache/rollup-plugin-typescript2/placeholder/runtime-core/src/render.d.ts","writeByteOrderMark":false,"text":"export declare function createRender(renderOptionDom: any): {\n    createApp: (rootComponent: any, rootProps: any) => {\n        _components: any;\n        _props: any;\n        _container: any;\n        mount(container: any): void;\n    };\n};\n"}}

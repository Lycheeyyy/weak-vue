{"version":3,"file":"runtime-core.esm-bundler.js","sources":["../../../node_modules/.pnpm/@vue+reactivity@3.5.14/node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js","../src/vnode.ts","../src/apiCreateApp.ts","../src/componentPublicInstance.ts","../src/component.ts","../src/render.ts","../src/h.ts"],"sourcesContent":["/**\n* @vue/reactivity v3.5.14\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\nimport { extend, hasChanged, isArray, isIntegerKey, isSymbol, isMap, hasOwn, makeMap, isObject, capitalize, toRawType, def, isFunction, EMPTY_OBJ, isSet, isPlainObject, remove, NOOP } from '@vue/shared';\n\nfunction warn(msg, ...args) {\n  console.warn(`[Vue warn] ${msg}`, ...args);\n}\n\nlet activeEffectScope;\nclass EffectScope {\n  constructor(detached = false) {\n    this.detached = detached;\n    /**\n     * @internal\n     */\n    this._active = true;\n    /**\n     * @internal track `on` calls, allow `on` call multiple times\n     */\n    this._on = 0;\n    /**\n     * @internal\n     */\n    this.effects = [];\n    /**\n     * @internal\n     */\n    this.cleanups = [];\n    this._isPaused = false;\n    this.parent = activeEffectScope;\n    if (!detached && activeEffectScope) {\n      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(\n        this\n      ) - 1;\n    }\n  }\n  get active() {\n    return this._active;\n  }\n  pause() {\n    if (this._active) {\n      this._isPaused = true;\n      let i, l;\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].pause();\n        }\n      }\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].pause();\n      }\n    }\n  }\n  /**\n   * Resumes the effect scope, including all child scopes and effects.\n   */\n  resume() {\n    if (this._active) {\n      if (this._isPaused) {\n        this._isPaused = false;\n        let i, l;\n        if (this.scopes) {\n          for (i = 0, l = this.scopes.length; i < l; i++) {\n            this.scopes[i].resume();\n          }\n        }\n        for (i = 0, l = this.effects.length; i < l; i++) {\n          this.effects[i].resume();\n        }\n      }\n    }\n  }\n  run(fn) {\n    if (this._active) {\n      const currentEffectScope = activeEffectScope;\n      try {\n        activeEffectScope = this;\n        return fn();\n      } finally {\n        activeEffectScope = currentEffectScope;\n      }\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(`cannot run an inactive effect scope.`);\n    }\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  on() {\n    if (++this._on === 1) {\n      this.prevScope = activeEffectScope;\n      activeEffectScope = this;\n    }\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  off() {\n    if (this._on > 0 && --this._on === 0) {\n      activeEffectScope = this.prevScope;\n      this.prevScope = void 0;\n    }\n  }\n  stop(fromParent) {\n    if (this._active) {\n      this._active = false;\n      let i, l;\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].stop();\n      }\n      this.effects.length = 0;\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\n        this.cleanups[i]();\n      }\n      this.cleanups.length = 0;\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].stop(true);\n        }\n        this.scopes.length = 0;\n      }\n      if (!this.detached && this.parent && !fromParent) {\n        const last = this.parent.scopes.pop();\n        if (last && last !== this) {\n          this.parent.scopes[this.index] = last;\n          last.index = this.index;\n        }\n      }\n      this.parent = void 0;\n    }\n  }\n}\nfunction effectScope(detached) {\n  return new EffectScope(detached);\n}\nfunction getCurrentScope() {\n  return activeEffectScope;\n}\nfunction onScopeDispose(fn, failSilently = false) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn);\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn(\n      `onScopeDispose() is called when there is no active effect scope to be associated with.`\n    );\n  }\n}\n\nlet activeSub;\nconst EffectFlags = {\n  \"ACTIVE\": 1,\n  \"1\": \"ACTIVE\",\n  \"RUNNING\": 2,\n  \"2\": \"RUNNING\",\n  \"TRACKING\": 4,\n  \"4\": \"TRACKING\",\n  \"NOTIFIED\": 8,\n  \"8\": \"NOTIFIED\",\n  \"DIRTY\": 16,\n  \"16\": \"DIRTY\",\n  \"ALLOW_RECURSE\": 32,\n  \"32\": \"ALLOW_RECURSE\",\n  \"PAUSED\": 64,\n  \"64\": \"PAUSED\",\n  \"EVALUATED\": 128,\n  \"128\": \"EVALUATED\"\n};\nconst pausedQueueEffects = /* @__PURE__ */ new WeakSet();\nclass ReactiveEffect {\n  constructor(fn) {\n    this.fn = fn;\n    /**\n     * @internal\n     */\n    this.deps = void 0;\n    /**\n     * @internal\n     */\n    this.depsTail = void 0;\n    /**\n     * @internal\n     */\n    this.flags = 1 | 4;\n    /**\n     * @internal\n     */\n    this.next = void 0;\n    /**\n     * @internal\n     */\n    this.cleanup = void 0;\n    this.scheduler = void 0;\n    if (activeEffectScope && activeEffectScope.active) {\n      activeEffectScope.effects.push(this);\n    }\n  }\n  pause() {\n    this.flags |= 64;\n  }\n  resume() {\n    if (this.flags & 64) {\n      this.flags &= -65;\n      if (pausedQueueEffects.has(this)) {\n        pausedQueueEffects.delete(this);\n        this.trigger();\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  notify() {\n    if (this.flags & 2 && !(this.flags & 32)) {\n      return;\n    }\n    if (!(this.flags & 8)) {\n      batch(this);\n    }\n  }\n  run() {\n    if (!(this.flags & 1)) {\n      return this.fn();\n    }\n    this.flags |= 2;\n    cleanupEffect(this);\n    prepareDeps(this);\n    const prevEffect = activeSub;\n    const prevShouldTrack = shouldTrack;\n    activeSub = this;\n    shouldTrack = true;\n    try {\n      return this.fn();\n    } finally {\n      if (!!(process.env.NODE_ENV !== \"production\") && activeSub !== this) {\n        warn(\n          \"Active effect was not restored correctly - this is likely a Vue internal bug.\"\n        );\n      }\n      cleanupDeps(this);\n      activeSub = prevEffect;\n      shouldTrack = prevShouldTrack;\n      this.flags &= -3;\n    }\n  }\n  stop() {\n    if (this.flags & 1) {\n      for (let link = this.deps; link; link = link.nextDep) {\n        removeSub(link);\n      }\n      this.deps = this.depsTail = void 0;\n      cleanupEffect(this);\n      this.onStop && this.onStop();\n      this.flags &= -2;\n    }\n  }\n  trigger() {\n    if (this.flags & 64) {\n      pausedQueueEffects.add(this);\n    } else if (this.scheduler) {\n      this.scheduler();\n    } else {\n      this.runIfDirty();\n    }\n  }\n  /**\n   * @internal\n   */\n  runIfDirty() {\n    if (isDirty(this)) {\n      this.run();\n    }\n  }\n  get dirty() {\n    return isDirty(this);\n  }\n}\nlet batchDepth = 0;\nlet batchedSub;\nlet batchedComputed;\nfunction batch(sub, isComputed = false) {\n  sub.flags |= 8;\n  if (isComputed) {\n    sub.next = batchedComputed;\n    batchedComputed = sub;\n    return;\n  }\n  sub.next = batchedSub;\n  batchedSub = sub;\n}\nfunction startBatch() {\n  batchDepth++;\n}\nfunction endBatch() {\n  if (--batchDepth > 0) {\n    return;\n  }\n  if (batchedComputed) {\n    let e = batchedComputed;\n    batchedComputed = void 0;\n    while (e) {\n      const next = e.next;\n      e.next = void 0;\n      e.flags &= -9;\n      e = next;\n    }\n  }\n  let error;\n  while (batchedSub) {\n    let e = batchedSub;\n    batchedSub = void 0;\n    while (e) {\n      const next = e.next;\n      e.next = void 0;\n      e.flags &= -9;\n      if (e.flags & 1) {\n        try {\n          ;\n          e.trigger();\n        } catch (err) {\n          if (!error) error = err;\n        }\n      }\n      e = next;\n    }\n  }\n  if (error) throw error;\n}\nfunction prepareDeps(sub) {\n  for (let link = sub.deps; link; link = link.nextDep) {\n    link.version = -1;\n    link.prevActiveLink = link.dep.activeLink;\n    link.dep.activeLink = link;\n  }\n}\nfunction cleanupDeps(sub) {\n  let head;\n  let tail = sub.depsTail;\n  let link = tail;\n  while (link) {\n    const prev = link.prevDep;\n    if (link.version === -1) {\n      if (link === tail) tail = prev;\n      removeSub(link);\n      removeDep(link);\n    } else {\n      head = link;\n    }\n    link.dep.activeLink = link.prevActiveLink;\n    link.prevActiveLink = void 0;\n    link = prev;\n  }\n  sub.deps = head;\n  sub.depsTail = tail;\n}\nfunction isDirty(sub) {\n  for (let link = sub.deps; link; link = link.nextDep) {\n    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {\n      return true;\n    }\n  }\n  if (sub._dirty) {\n    return true;\n  }\n  return false;\n}\nfunction refreshComputed(computed) {\n  if (computed.flags & 4 && !(computed.flags & 16)) {\n    return;\n  }\n  computed.flags &= -17;\n  if (computed.globalVersion === globalVersion) {\n    return;\n  }\n  computed.globalVersion = globalVersion;\n  if (!computed.isSSR && computed.flags & 128 && (!computed.deps && !computed._dirty || !isDirty(computed))) {\n    return;\n  }\n  computed.flags |= 2;\n  const dep = computed.dep;\n  const prevSub = activeSub;\n  const prevShouldTrack = shouldTrack;\n  activeSub = computed;\n  shouldTrack = true;\n  try {\n    prepareDeps(computed);\n    const value = computed.fn(computed._value);\n    if (dep.version === 0 || hasChanged(value, computed._value)) {\n      computed.flags |= 128;\n      computed._value = value;\n      dep.version++;\n    }\n  } catch (err) {\n    dep.version++;\n    throw err;\n  } finally {\n    activeSub = prevSub;\n    shouldTrack = prevShouldTrack;\n    cleanupDeps(computed);\n    computed.flags &= -3;\n  }\n}\nfunction removeSub(link, soft = false) {\n  const { dep, prevSub, nextSub } = link;\n  if (prevSub) {\n    prevSub.nextSub = nextSub;\n    link.prevSub = void 0;\n  }\n  if (nextSub) {\n    nextSub.prevSub = prevSub;\n    link.nextSub = void 0;\n  }\n  if (!!(process.env.NODE_ENV !== \"production\") && dep.subsHead === link) {\n    dep.subsHead = nextSub;\n  }\n  if (dep.subs === link) {\n    dep.subs = prevSub;\n    if (!prevSub && dep.computed) {\n      dep.computed.flags &= -5;\n      for (let l = dep.computed.deps; l; l = l.nextDep) {\n        removeSub(l, true);\n      }\n    }\n  }\n  if (!soft && !--dep.sc && dep.map) {\n    dep.map.delete(dep.key);\n  }\n}\nfunction removeDep(link) {\n  const { prevDep, nextDep } = link;\n  if (prevDep) {\n    prevDep.nextDep = nextDep;\n    link.prevDep = void 0;\n  }\n  if (nextDep) {\n    nextDep.prevDep = prevDep;\n    link.nextDep = void 0;\n  }\n}\nfunction effect(fn, options) {\n  if (fn.effect instanceof ReactiveEffect) {\n    fn = fn.effect.fn;\n  }\n  const e = new ReactiveEffect(fn);\n  if (options) {\n    extend(e, options);\n  }\n  try {\n    e.run();\n  } catch (err) {\n    e.stop();\n    throw err;\n  }\n  const runner = e.run.bind(e);\n  runner.effect = e;\n  return runner;\n}\nfunction stop(runner) {\n  runner.effect.stop();\n}\nlet shouldTrack = true;\nconst trackStack = [];\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\nfunction resetTracking() {\n  const last = trackStack.pop();\n  shouldTrack = last === void 0 ? true : last;\n}\nfunction onEffectCleanup(fn, failSilently = false) {\n  if (activeSub instanceof ReactiveEffect) {\n    activeSub.cleanup = fn;\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn(\n      `onEffectCleanup() was called when there was no active effect to associate with.`\n    );\n  }\n}\nfunction cleanupEffect(e) {\n  const { cleanup } = e;\n  e.cleanup = void 0;\n  if (cleanup) {\n    const prevSub = activeSub;\n    activeSub = void 0;\n    try {\n      cleanup();\n    } finally {\n      activeSub = prevSub;\n    }\n  }\n}\n\nlet globalVersion = 0;\nclass Link {\n  constructor(sub, dep) {\n    this.sub = sub;\n    this.dep = dep;\n    this.version = dep.version;\n    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;\n  }\n}\nclass Dep {\n  constructor(computed) {\n    this.computed = computed;\n    this.version = 0;\n    /**\n     * Link between this dep and the current active effect\n     */\n    this.activeLink = void 0;\n    /**\n     * Doubly linked list representing the subscribing effects (tail)\n     */\n    this.subs = void 0;\n    /**\n     * For object property deps cleanup\n     */\n    this.map = void 0;\n    this.key = void 0;\n    /**\n     * Subscriber counter\n     */\n    this.sc = 0;\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      this.subsHead = void 0;\n    }\n  }\n  track(debugInfo) {\n    if (!activeSub || !shouldTrack || activeSub === this.computed) {\n      return;\n    }\n    let link = this.activeLink;\n    if (link === void 0 || link.sub !== activeSub) {\n      link = this.activeLink = new Link(activeSub, this);\n      if (!activeSub.deps) {\n        activeSub.deps = activeSub.depsTail = link;\n      } else {\n        link.prevDep = activeSub.depsTail;\n        activeSub.depsTail.nextDep = link;\n        activeSub.depsTail = link;\n      }\n      addSub(link);\n    } else if (link.version === -1) {\n      link.version = this.version;\n      if (link.nextDep) {\n        const next = link.nextDep;\n        next.prevDep = link.prevDep;\n        if (link.prevDep) {\n          link.prevDep.nextDep = next;\n        }\n        link.prevDep = activeSub.depsTail;\n        link.nextDep = void 0;\n        activeSub.depsTail.nextDep = link;\n        activeSub.depsTail = link;\n        if (activeSub.deps === link) {\n          activeSub.deps = next;\n        }\n      }\n    }\n    if (!!(process.env.NODE_ENV !== \"production\") && activeSub.onTrack) {\n      activeSub.onTrack(\n        extend(\n          {\n            effect: activeSub\n          },\n          debugInfo\n        )\n      );\n    }\n    return link;\n  }\n  trigger(debugInfo) {\n    this.version++;\n    globalVersion++;\n    this.notify(debugInfo);\n  }\n  notify(debugInfo) {\n    startBatch();\n    try {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        for (let head = this.subsHead; head; head = head.nextSub) {\n          if (head.sub.onTrigger && !(head.sub.flags & 8)) {\n            head.sub.onTrigger(\n              extend(\n                {\n                  effect: head.sub\n                },\n                debugInfo\n              )\n            );\n          }\n        }\n      }\n      for (let link = this.subs; link; link = link.prevSub) {\n        if (link.sub.notify()) {\n          ;\n          link.sub.dep.notify();\n        }\n      }\n    } finally {\n      endBatch();\n    }\n  }\n}\nfunction addSub(link) {\n  link.dep.sc++;\n  if (link.sub.flags & 4) {\n    const computed = link.dep.computed;\n    if (computed && !link.dep.subs) {\n      computed.flags |= 4 | 16;\n      for (let l = computed.deps; l; l = l.nextDep) {\n        addSub(l);\n      }\n    }\n    const currentTail = link.dep.subs;\n    if (currentTail !== link) {\n      link.prevSub = currentTail;\n      if (currentTail) currentTail.nextSub = link;\n    }\n    if (!!(process.env.NODE_ENV !== \"production\") && link.dep.subsHead === void 0) {\n      link.dep.subsHead = link;\n    }\n    link.dep.subs = link;\n  }\n}\nconst targetMap = /* @__PURE__ */ new WeakMap();\nconst ITERATE_KEY = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? \"Object iterate\" : \"\"\n);\nconst MAP_KEY_ITERATE_KEY = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? \"Map keys iterate\" : \"\"\n);\nconst ARRAY_ITERATE_KEY = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? \"Array iterate\" : \"\"\n);\nfunction track(target, type, key) {\n  if (shouldTrack && activeSub) {\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n      depsMap.set(key, dep = new Dep());\n      dep.map = depsMap;\n      dep.key = key;\n    }\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      dep.track({\n        target,\n        type,\n        key\n      });\n    } else {\n      dep.track();\n    }\n  }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) {\n    globalVersion++;\n    return;\n  }\n  const run = (dep) => {\n    if (dep) {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        dep.trigger({\n          target,\n          type,\n          key,\n          newValue,\n          oldValue,\n          oldTarget\n        });\n      } else {\n        dep.trigger();\n      }\n    }\n  };\n  startBatch();\n  if (type === \"clear\") {\n    depsMap.forEach(run);\n  } else {\n    const targetIsArray = isArray(target);\n    const isArrayIndex = targetIsArray && isIntegerKey(key);\n    if (targetIsArray && key === \"length\") {\n      const newLength = Number(newValue);\n      depsMap.forEach((dep, key2) => {\n        if (key2 === \"length\" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {\n          run(dep);\n        }\n      });\n    } else {\n      if (key !== void 0 || depsMap.has(void 0)) {\n        run(depsMap.get(key));\n      }\n      if (isArrayIndex) {\n        run(depsMap.get(ARRAY_ITERATE_KEY));\n      }\n      switch (type) {\n        case \"add\":\n          if (!targetIsArray) {\n            run(depsMap.get(ITERATE_KEY));\n            if (isMap(target)) {\n              run(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          } else if (isArrayIndex) {\n            run(depsMap.get(\"length\"));\n          }\n          break;\n        case \"delete\":\n          if (!targetIsArray) {\n            run(depsMap.get(ITERATE_KEY));\n            if (isMap(target)) {\n              run(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          }\n          break;\n        case \"set\":\n          if (isMap(target)) {\n            run(depsMap.get(ITERATE_KEY));\n          }\n          break;\n      }\n    }\n  }\n  endBatch();\n}\nfunction getDepFromReactive(object, key) {\n  const depMap = targetMap.get(object);\n  return depMap && depMap.get(key);\n}\n\nfunction reactiveReadArray(array) {\n  const raw = toRaw(array);\n  if (raw === array) return raw;\n  track(raw, \"iterate\", ARRAY_ITERATE_KEY);\n  return isShallow(array) ? raw : raw.map(toReactive);\n}\nfunction shallowReadArray(arr) {\n  track(arr = toRaw(arr), \"iterate\", ARRAY_ITERATE_KEY);\n  return arr;\n}\nconst arrayInstrumentations = {\n  __proto__: null,\n  [Symbol.iterator]() {\n    return iterator(this, Symbol.iterator, toReactive);\n  },\n  concat(...args) {\n    return reactiveReadArray(this).concat(\n      ...args.map((x) => isArray(x) ? reactiveReadArray(x) : x)\n    );\n  },\n  entries() {\n    return iterator(this, \"entries\", (value) => {\n      value[1] = toReactive(value[1]);\n      return value;\n    });\n  },\n  every(fn, thisArg) {\n    return apply(this, \"every\", fn, thisArg, void 0, arguments);\n  },\n  filter(fn, thisArg) {\n    return apply(this, \"filter\", fn, thisArg, (v) => v.map(toReactive), arguments);\n  },\n  find(fn, thisArg) {\n    return apply(this, \"find\", fn, thisArg, toReactive, arguments);\n  },\n  findIndex(fn, thisArg) {\n    return apply(this, \"findIndex\", fn, thisArg, void 0, arguments);\n  },\n  findLast(fn, thisArg) {\n    return apply(this, \"findLast\", fn, thisArg, toReactive, arguments);\n  },\n  findLastIndex(fn, thisArg) {\n    return apply(this, \"findLastIndex\", fn, thisArg, void 0, arguments);\n  },\n  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement\n  forEach(fn, thisArg) {\n    return apply(this, \"forEach\", fn, thisArg, void 0, arguments);\n  },\n  includes(...args) {\n    return searchProxy(this, \"includes\", args);\n  },\n  indexOf(...args) {\n    return searchProxy(this, \"indexOf\", args);\n  },\n  join(separator) {\n    return reactiveReadArray(this).join(separator);\n  },\n  // keys() iterator only reads `length`, no optimisation required\n  lastIndexOf(...args) {\n    return searchProxy(this, \"lastIndexOf\", args);\n  },\n  map(fn, thisArg) {\n    return apply(this, \"map\", fn, thisArg, void 0, arguments);\n  },\n  pop() {\n    return noTracking(this, \"pop\");\n  },\n  push(...args) {\n    return noTracking(this, \"push\", args);\n  },\n  reduce(fn, ...args) {\n    return reduce(this, \"reduce\", fn, args);\n  },\n  reduceRight(fn, ...args) {\n    return reduce(this, \"reduceRight\", fn, args);\n  },\n  shift() {\n    return noTracking(this, \"shift\");\n  },\n  // slice could use ARRAY_ITERATE but also seems to beg for range tracking\n  some(fn, thisArg) {\n    return apply(this, \"some\", fn, thisArg, void 0, arguments);\n  },\n  splice(...args) {\n    return noTracking(this, \"splice\", args);\n  },\n  toReversed() {\n    return reactiveReadArray(this).toReversed();\n  },\n  toSorted(comparer) {\n    return reactiveReadArray(this).toSorted(comparer);\n  },\n  toSpliced(...args) {\n    return reactiveReadArray(this).toSpliced(...args);\n  },\n  unshift(...args) {\n    return noTracking(this, \"unshift\", args);\n  },\n  values() {\n    return iterator(this, \"values\", toReactive);\n  }\n};\nfunction iterator(self, method, wrapValue) {\n  const arr = shallowReadArray(self);\n  const iter = arr[method]();\n  if (arr !== self && !isShallow(self)) {\n    iter._next = iter.next;\n    iter.next = () => {\n      const result = iter._next();\n      if (result.value) {\n        result.value = wrapValue(result.value);\n      }\n      return result;\n    };\n  }\n  return iter;\n}\nconst arrayProto = Array.prototype;\nfunction apply(self, method, fn, thisArg, wrappedRetFn, args) {\n  const arr = shallowReadArray(self);\n  const needsWrap = arr !== self && !isShallow(self);\n  const methodFn = arr[method];\n  if (methodFn !== arrayProto[method]) {\n    const result2 = methodFn.apply(self, args);\n    return needsWrap ? toReactive(result2) : result2;\n  }\n  let wrappedFn = fn;\n  if (arr !== self) {\n    if (needsWrap) {\n      wrappedFn = function(item, index) {\n        return fn.call(this, toReactive(item), index, self);\n      };\n    } else if (fn.length > 2) {\n      wrappedFn = function(item, index) {\n        return fn.call(this, item, index, self);\n      };\n    }\n  }\n  const result = methodFn.call(arr, wrappedFn, thisArg);\n  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;\n}\nfunction reduce(self, method, fn, args) {\n  const arr = shallowReadArray(self);\n  let wrappedFn = fn;\n  if (arr !== self) {\n    if (!isShallow(self)) {\n      wrappedFn = function(acc, item, index) {\n        return fn.call(this, acc, toReactive(item), index, self);\n      };\n    } else if (fn.length > 3) {\n      wrappedFn = function(acc, item, index) {\n        return fn.call(this, acc, item, index, self);\n      };\n    }\n  }\n  return arr[method](wrappedFn, ...args);\n}\nfunction searchProxy(self, method, args) {\n  const arr = toRaw(self);\n  track(arr, \"iterate\", ARRAY_ITERATE_KEY);\n  const res = arr[method](...args);\n  if ((res === -1 || res === false) && isProxy(args[0])) {\n    args[0] = toRaw(args[0]);\n    return arr[method](...args);\n  }\n  return res;\n}\nfunction noTracking(self, method, args = []) {\n  pauseTracking();\n  startBatch();\n  const res = toRaw(self)[method].apply(self, args);\n  endBatch();\n  resetTracking();\n  return res;\n}\n\nconst isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set(\n  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== \"arguments\" && key !== \"caller\").map((key) => Symbol[key]).filter(isSymbol)\n);\nfunction hasOwnProperty(key) {\n  if (!isSymbol(key)) key = String(key);\n  const obj = toRaw(this);\n  track(obj, \"has\", key);\n  return obj.hasOwnProperty(key);\n}\nclass BaseReactiveHandler {\n  constructor(_isReadonly = false, _isShallow = false) {\n    this._isReadonly = _isReadonly;\n    this._isShallow = _isShallow;\n  }\n  get(target, key, receiver) {\n    if (key === \"__v_skip\") return target[\"__v_skip\"];\n    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_isShallow\") {\n      return isShallow2;\n    } else if (key === \"__v_raw\") {\n      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype\n      // this means the receiver is a user proxy of the reactive proxy\n      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {\n        return target;\n      }\n      return;\n    }\n    const targetIsArray = isArray(target);\n    if (!isReadonly2) {\n      let fn;\n      if (targetIsArray && (fn = arrayInstrumentations[key])) {\n        return fn;\n      }\n      if (key === \"hasOwnProperty\") {\n        return hasOwnProperty;\n      }\n    }\n    const res = Reflect.get(\n      target,\n      key,\n      // if this is a proxy wrapping a ref, return methods using the raw ref\n      // as receiver so that we don't have to call `toRaw` on the ref in all\n      // its class methods\n      isRef(target) ? target : receiver\n    );\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n    if (!isReadonly2) {\n      track(target, \"get\", key);\n    }\n    if (isShallow2) {\n      return res;\n    }\n    if (isRef(res)) {\n      return targetIsArray && isIntegerKey(key) ? res : res.value;\n    }\n    if (isObject(res)) {\n      return isReadonly2 ? readonly(res) : reactive(res);\n    }\n    return res;\n  }\n}\nclass MutableReactiveHandler extends BaseReactiveHandler {\n  constructor(isShallow2 = false) {\n    super(false, isShallow2);\n  }\n  set(target, key, value, receiver) {\n    let oldValue = target[key];\n    if (!this._isShallow) {\n      const isOldValueReadonly = isReadonly(oldValue);\n      if (!isShallow(value) && !isReadonly(value)) {\n        oldValue = toRaw(oldValue);\n        value = toRaw(value);\n      }\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n        if (isOldValueReadonly) {\n          return false;\n        } else {\n          oldValue.value = value;\n          return true;\n        }\n      }\n    }\n    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);\n    const result = Reflect.set(\n      target,\n      key,\n      value,\n      isRef(target) ? target : receiver\n    );\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, \"add\", key, value);\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\", key, value, oldValue);\n      }\n    }\n    return result;\n  }\n  deleteProperty(target, key) {\n    const hadKey = hasOwn(target, key);\n    const oldValue = target[key];\n    const result = Reflect.deleteProperty(target, key);\n    if (result && hadKey) {\n      trigger(target, \"delete\", key, void 0, oldValue);\n    }\n    return result;\n  }\n  has(target, key) {\n    const result = Reflect.has(target, key);\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\n      track(target, \"has\", key);\n    }\n    return result;\n  }\n  ownKeys(target) {\n    track(\n      target,\n      \"iterate\",\n      isArray(target) ? \"length\" : ITERATE_KEY\n    );\n    return Reflect.ownKeys(target);\n  }\n}\nclass ReadonlyReactiveHandler extends BaseReactiveHandler {\n  constructor(isShallow2 = false) {\n    super(true, isShallow2);\n  }\n  set(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      );\n    }\n    return true;\n  }\n  deleteProperty(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `Delete operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      );\n    }\n    return true;\n  }\n}\nconst mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();\nconst readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();\nconst shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);\nconst shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);\n\nconst toShallow = (value) => value;\nconst getProto = (v) => Reflect.getPrototypeOf(v);\nfunction createIterableMethod(method, isReadonly2, isShallow2) {\n  return function(...args) {\n    const target = this[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const targetIsMap = isMap(rawTarget);\n    const isPair = method === \"entries\" || method === Symbol.iterator && targetIsMap;\n    const isKeyOnly = method === \"keys\" && targetIsMap;\n    const innerIterator = target[method](...args);\n    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;\n    !isReadonly2 && track(\n      rawTarget,\n      \"iterate\",\n      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY\n    );\n    return {\n      // iterator protocol\n      next() {\n        const { value, done } = innerIterator.next();\n        return done ? { value, done } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n  };\n}\nfunction createReadonlyMethod(type) {\n  return function(...args) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n      warn(\n        `${capitalize(type)} operation ${key}failed: target is readonly.`,\n        toRaw(this)\n      );\n    }\n    return type === \"delete\" ? false : type === \"clear\" ? void 0 : this;\n  };\n}\nfunction createInstrumentations(readonly, shallow) {\n  const instrumentations = {\n    get(key) {\n      const target = this[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const rawKey = toRaw(key);\n      if (!readonly) {\n        if (hasChanged(key, rawKey)) {\n          track(rawTarget, \"get\", key);\n        }\n        track(rawTarget, \"get\", rawKey);\n      }\n      const { has } = getProto(rawTarget);\n      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;\n      if (has.call(rawTarget, key)) {\n        return wrap(target.get(key));\n      } else if (has.call(rawTarget, rawKey)) {\n        return wrap(target.get(rawKey));\n      } else if (target !== rawTarget) {\n        target.get(key);\n      }\n    },\n    get size() {\n      const target = this[\"__v_raw\"];\n      !readonly && track(toRaw(target), \"iterate\", ITERATE_KEY);\n      return Reflect.get(target, \"size\", target);\n    },\n    has(key) {\n      const target = this[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const rawKey = toRaw(key);\n      if (!readonly) {\n        if (hasChanged(key, rawKey)) {\n          track(rawTarget, \"has\", key);\n        }\n        track(rawTarget, \"has\", rawKey);\n      }\n      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n    },\n    forEach(callback, thisArg) {\n      const observed = this;\n      const target = observed[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;\n      !readonly && track(rawTarget, \"iterate\", ITERATE_KEY);\n      return target.forEach((value, key) => {\n        return callback.call(thisArg, wrap(value), wrap(key), observed);\n      });\n    }\n  };\n  extend(\n    instrumentations,\n    readonly ? {\n      add: createReadonlyMethod(\"add\"),\n      set: createReadonlyMethod(\"set\"),\n      delete: createReadonlyMethod(\"delete\"),\n      clear: createReadonlyMethod(\"clear\")\n    } : {\n      add(value) {\n        if (!shallow && !isShallow(value) && !isReadonly(value)) {\n          value = toRaw(value);\n        }\n        const target = toRaw(this);\n        const proto = getProto(target);\n        const hadKey = proto.has.call(target, value);\n        if (!hadKey) {\n          target.add(value);\n          trigger(target, \"add\", value, value);\n        }\n        return this;\n      },\n      set(key, value) {\n        if (!shallow && !isShallow(value) && !isReadonly(value)) {\n          value = toRaw(value);\n        }\n        const target = toRaw(this);\n        const { has, get } = getProto(target);\n        let hadKey = has.call(target, key);\n        if (!hadKey) {\n          key = toRaw(key);\n          hadKey = has.call(target, key);\n        } else if (!!(process.env.NODE_ENV !== \"production\")) {\n          checkIdentityKeys(target, has, key);\n        }\n        const oldValue = get.call(target, key);\n        target.set(key, value);\n        if (!hadKey) {\n          trigger(target, \"add\", key, value);\n        } else if (hasChanged(value, oldValue)) {\n          trigger(target, \"set\", key, value, oldValue);\n        }\n        return this;\n      },\n      delete(key) {\n        const target = toRaw(this);\n        const { has, get } = getProto(target);\n        let hadKey = has.call(target, key);\n        if (!hadKey) {\n          key = toRaw(key);\n          hadKey = has.call(target, key);\n        } else if (!!(process.env.NODE_ENV !== \"production\")) {\n          checkIdentityKeys(target, has, key);\n        }\n        const oldValue = get ? get.call(target, key) : void 0;\n        const result = target.delete(key);\n        if (hadKey) {\n          trigger(target, \"delete\", key, void 0, oldValue);\n        }\n        return result;\n      },\n      clear() {\n        const target = toRaw(this);\n        const hadItems = target.size !== 0;\n        const oldTarget = !!(process.env.NODE_ENV !== \"production\") ? isMap(target) ? new Map(target) : new Set(target) : void 0;\n        const result = target.clear();\n        if (hadItems) {\n          trigger(\n            target,\n            \"clear\",\n            void 0,\n            void 0,\n            oldTarget\n          );\n        }\n        return result;\n      }\n    }\n  );\n  const iteratorMethods = [\n    \"keys\",\n    \"values\",\n    \"entries\",\n    Symbol.iterator\n  ];\n  iteratorMethods.forEach((method) => {\n    instrumentations[method] = createIterableMethod(method, readonly, shallow);\n  });\n  return instrumentations;\n}\nfunction createInstrumentationGetter(isReadonly2, shallow) {\n  const instrumentations = createInstrumentations(isReadonly2, shallow);\n  return (target, key, receiver) => {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_raw\") {\n      return target;\n    }\n    return Reflect.get(\n      hasOwn(instrumentations, key) && key in target ? instrumentations : target,\n      key,\n      receiver\n    );\n  };\n}\nconst mutableCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, true)\n};\nfunction checkIdentityKeys(target, has, key) {\n  const rawKey = toRaw(key);\n  if (rawKey !== key && has.call(target, rawKey)) {\n    const type = toRawType(target);\n    warn(\n      `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`\n    );\n  }\n}\n\nconst reactiveMap = /* @__PURE__ */ new WeakMap();\nconst shallowReactiveMap = /* @__PURE__ */ new WeakMap();\nconst readonlyMap = /* @__PURE__ */ new WeakMap();\nconst shallowReadonlyMap = /* @__PURE__ */ new WeakMap();\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case \"Object\":\n    case \"Array\":\n      return 1 /* COMMON */;\n    case \"Map\":\n    case \"Set\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n      return 2 /* COLLECTION */;\n    default:\n      return 0 /* INVALID */;\n  }\n}\nfunction getTargetType(value) {\n  return value[\"__v_skip\"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap(toRawType(value));\n}\nfunction reactive(target) {\n  if (isReadonly(target)) {\n    return target;\n  }\n  return createReactiveObject(\n    target,\n    false,\n    mutableHandlers,\n    mutableCollectionHandlers,\n    reactiveMap\n  );\n}\nfunction shallowReactive(target) {\n  return createReactiveObject(\n    target,\n    false,\n    shallowReactiveHandlers,\n    shallowCollectionHandlers,\n    shallowReactiveMap\n  );\n}\nfunction readonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    readonlyHandlers,\n    readonlyCollectionHandlers,\n    readonlyMap\n  );\n}\nfunction shallowReadonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    shallowReadonlyHandlers,\n    shallowReadonlyCollectionHandlers,\n    shallowReadonlyMap\n  );\n}\nfunction createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {\n  if (!isObject(target)) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `value cannot be made ${isReadonly2 ? \"readonly\" : \"reactive\"}: ${String(\n          target\n        )}`\n      );\n    }\n    return target;\n  }\n  if (target[\"__v_raw\"] && !(isReadonly2 && target[\"__v_isReactive\"])) {\n    return target;\n  }\n  const targetType = getTargetType(target);\n  if (targetType === 0 /* INVALID */) {\n    return target;\n  }\n  const existingProxy = proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n  const proxy = new Proxy(\n    target,\n    targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers\n  );\n  proxyMap.set(target, proxy);\n  return proxy;\n}\nfunction isReactive(value) {\n  if (isReadonly(value)) {\n    return isReactive(value[\"__v_raw\"]);\n  }\n  return !!(value && value[\"__v_isReactive\"]);\n}\nfunction isReadonly(value) {\n  return !!(value && value[\"__v_isReadonly\"]);\n}\nfunction isShallow(value) {\n  return !!(value && value[\"__v_isShallow\"]);\n}\nfunction isProxy(value) {\n  return value ? !!value[\"__v_raw\"] : false;\n}\nfunction toRaw(observed) {\n  const raw = observed && observed[\"__v_raw\"];\n  return raw ? toRaw(raw) : observed;\n}\nfunction markRaw(value) {\n  if (!hasOwn(value, \"__v_skip\") && Object.isExtensible(value)) {\n    def(value, \"__v_skip\", true);\n  }\n  return value;\n}\nconst toReactive = (value) => isObject(value) ? reactive(value) : value;\nconst toReadonly = (value) => isObject(value) ? readonly(value) : value;\n\nfunction isRef(r) {\n  return r ? r[\"__v_isRef\"] === true : false;\n}\nfunction ref(value) {\n  return createRef(value, false);\n}\nfunction shallowRef(value) {\n  return createRef(value, true);\n}\nfunction createRef(rawValue, shallow) {\n  if (isRef(rawValue)) {\n    return rawValue;\n  }\n  return new RefImpl(rawValue, shallow);\n}\nclass RefImpl {\n  constructor(value, isShallow2) {\n    this.dep = new Dep();\n    this[\"__v_isRef\"] = true;\n    this[\"__v_isShallow\"] = false;\n    this._rawValue = isShallow2 ? value : toRaw(value);\n    this._value = isShallow2 ? value : toReactive(value);\n    this[\"__v_isShallow\"] = isShallow2;\n  }\n  get value() {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      this.dep.track({\n        target: this,\n        type: \"get\",\n        key: \"value\"\n      });\n    } else {\n      this.dep.track();\n    }\n    return this._value;\n  }\n  set value(newValue) {\n    const oldValue = this._rawValue;\n    const useDirectValue = this[\"__v_isShallow\"] || isShallow(newValue) || isReadonly(newValue);\n    newValue = useDirectValue ? newValue : toRaw(newValue);\n    if (hasChanged(newValue, oldValue)) {\n      this._rawValue = newValue;\n      this._value = useDirectValue ? newValue : toReactive(newValue);\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        this.dep.trigger({\n          target: this,\n          type: \"set\",\n          key: \"value\",\n          newValue,\n          oldValue\n        });\n      } else {\n        this.dep.trigger();\n      }\n    }\n  }\n}\nfunction triggerRef(ref2) {\n  if (ref2.dep) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      ref2.dep.trigger({\n        target: ref2,\n        type: \"set\",\n        key: \"value\",\n        newValue: ref2._value\n      });\n    } else {\n      ref2.dep.trigger();\n    }\n  }\n}\nfunction unref(ref2) {\n  return isRef(ref2) ? ref2.value : ref2;\n}\nfunction toValue(source) {\n  return isFunction(source) ? source() : unref(source);\n}\nconst shallowUnwrapHandlers = {\n  get: (target, key, receiver) => key === \"__v_raw\" ? target : unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key];\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value;\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n};\nfunction proxyRefs(objectWithRefs) {\n  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\nclass CustomRefImpl {\n  constructor(factory) {\n    this[\"__v_isRef\"] = true;\n    this._value = void 0;\n    const dep = this.dep = new Dep();\n    const { get, set } = factory(dep.track.bind(dep), dep.trigger.bind(dep));\n    this._get = get;\n    this._set = set;\n  }\n  get value() {\n    return this._value = this._get();\n  }\n  set value(newVal) {\n    this._set(newVal);\n  }\n}\nfunction customRef(factory) {\n  return new CustomRefImpl(factory);\n}\nfunction toRefs(object) {\n  if (!!(process.env.NODE_ENV !== \"production\") && !isProxy(object)) {\n    warn(`toRefs() expects a reactive object but received a plain one.`);\n  }\n  const ret = isArray(object) ? new Array(object.length) : {};\n  for (const key in object) {\n    ret[key] = propertyToRef(object, key);\n  }\n  return ret;\n}\nclass ObjectRefImpl {\n  constructor(_object, _key, _defaultValue) {\n    this._object = _object;\n    this._key = _key;\n    this._defaultValue = _defaultValue;\n    this[\"__v_isRef\"] = true;\n    this._value = void 0;\n  }\n  get value() {\n    const val = this._object[this._key];\n    return this._value = val === void 0 ? this._defaultValue : val;\n  }\n  set value(newVal) {\n    this._object[this._key] = newVal;\n  }\n  get dep() {\n    return getDepFromReactive(toRaw(this._object), this._key);\n  }\n}\nclass GetterRefImpl {\n  constructor(_getter) {\n    this._getter = _getter;\n    this[\"__v_isRef\"] = true;\n    this[\"__v_isReadonly\"] = true;\n    this._value = void 0;\n  }\n  get value() {\n    return this._value = this._getter();\n  }\n}\nfunction toRef(source, key, defaultValue) {\n  if (isRef(source)) {\n    return source;\n  } else if (isFunction(source)) {\n    return new GetterRefImpl(source);\n  } else if (isObject(source) && arguments.length > 1) {\n    return propertyToRef(source, key, defaultValue);\n  } else {\n    return ref(source);\n  }\n}\nfunction propertyToRef(source, key, defaultValue) {\n  const val = source[key];\n  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);\n}\n\nclass ComputedRefImpl {\n  constructor(fn, setter, isSSR) {\n    this.fn = fn;\n    this.setter = setter;\n    /**\n     * @internal\n     */\n    this._value = void 0;\n    /**\n     * @internal\n     */\n    this.dep = new Dep(this);\n    /**\n     * @internal\n     */\n    this.__v_isRef = true;\n    // TODO isolatedDeclarations \"__v_isReadonly\"\n    // A computed is also a subscriber that tracks other deps\n    /**\n     * @internal\n     */\n    this.deps = void 0;\n    /**\n     * @internal\n     */\n    this.depsTail = void 0;\n    /**\n     * @internal\n     */\n    this.flags = 16;\n    /**\n     * @internal\n     */\n    this.globalVersion = globalVersion - 1;\n    /**\n     * @internal\n     */\n    this.next = void 0;\n    // for backwards compat\n    this.effect = this;\n    this[\"__v_isReadonly\"] = !setter;\n    this.isSSR = isSSR;\n  }\n  /**\n   * @internal\n   */\n  notify() {\n    this.flags |= 16;\n    if (!(this.flags & 8) && // avoid infinite self recursion\n    activeSub !== this) {\n      batch(this, true);\n      return true;\n    } else if (!!(process.env.NODE_ENV !== \"production\")) ;\n  }\n  get value() {\n    const link = !!(process.env.NODE_ENV !== \"production\") ? this.dep.track({\n      target: this,\n      type: \"get\",\n      key: \"value\"\n    }) : this.dep.track();\n    refreshComputed(this);\n    if (link) {\n      link.version = this.dep.version;\n    }\n    return this._value;\n  }\n  set value(newValue) {\n    if (this.setter) {\n      this.setter(newValue);\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\"Write operation failed: computed value is readonly\");\n    }\n  }\n}\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\n  let getter;\n  let setter;\n  if (isFunction(getterOrOptions)) {\n    getter = getterOrOptions;\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n  const cRef = new ComputedRefImpl(getter, setter, isSSR);\n  if (!!(process.env.NODE_ENV !== \"production\") && debugOptions && !isSSR) {\n    cRef.onTrack = debugOptions.onTrack;\n    cRef.onTrigger = debugOptions.onTrigger;\n  }\n  return cRef;\n}\n\nconst TrackOpTypes = {\n  \"GET\": \"get\",\n  \"HAS\": \"has\",\n  \"ITERATE\": \"iterate\"\n};\nconst TriggerOpTypes = {\n  \"SET\": \"set\",\n  \"ADD\": \"add\",\n  \"DELETE\": \"delete\",\n  \"CLEAR\": \"clear\"\n};\nconst ReactiveFlags = {\n  \"SKIP\": \"__v_skip\",\n  \"IS_REACTIVE\": \"__v_isReactive\",\n  \"IS_READONLY\": \"__v_isReadonly\",\n  \"IS_SHALLOW\": \"__v_isShallow\",\n  \"RAW\": \"__v_raw\",\n  \"IS_REF\": \"__v_isRef\"\n};\n\nconst WatchErrorCodes = {\n  \"WATCH_GETTER\": 2,\n  \"2\": \"WATCH_GETTER\",\n  \"WATCH_CALLBACK\": 3,\n  \"3\": \"WATCH_CALLBACK\",\n  \"WATCH_CLEANUP\": 4,\n  \"4\": \"WATCH_CLEANUP\"\n};\nconst INITIAL_WATCHER_VALUE = {};\nconst cleanupMap = /* @__PURE__ */ new WeakMap();\nlet activeWatcher = void 0;\nfunction getCurrentWatcher() {\n  return activeWatcher;\n}\nfunction onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {\n  if (owner) {\n    let cleanups = cleanupMap.get(owner);\n    if (!cleanups) cleanupMap.set(owner, cleanups = []);\n    cleanups.push(cleanupFn);\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn(\n      `onWatcherCleanup() was called when there was no active watcher to associate with.`\n    );\n  }\n}\nfunction watch(source, cb, options = EMPTY_OBJ) {\n  const { immediate, deep, once, scheduler, augmentJob, call } = options;\n  const warnInvalidSource = (s) => {\n    (options.onWarn || warn)(\n      `Invalid watch source: `,\n      s,\n      `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`\n    );\n  };\n  const reactiveGetter = (source2) => {\n    if (deep) return source2;\n    if (isShallow(source2) || deep === false || deep === 0)\n      return traverse(source2, 1);\n    return traverse(source2);\n  };\n  let effect;\n  let getter;\n  let cleanup;\n  let boundCleanup;\n  let forceTrigger = false;\n  let isMultiSource = false;\n  if (isRef(source)) {\n    getter = () => source.value;\n    forceTrigger = isShallow(source);\n  } else if (isReactive(source)) {\n    getter = () => reactiveGetter(source);\n    forceTrigger = true;\n  } else if (isArray(source)) {\n    isMultiSource = true;\n    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));\n    getter = () => source.map((s) => {\n      if (isRef(s)) {\n        return s.value;\n      } else if (isReactive(s)) {\n        return reactiveGetter(s);\n      } else if (isFunction(s)) {\n        return call ? call(s, 2) : s();\n      } else {\n        !!(process.env.NODE_ENV !== \"production\") && warnInvalidSource(s);\n      }\n    });\n  } else if (isFunction(source)) {\n    if (cb) {\n      getter = call ? () => call(source, 2) : source;\n    } else {\n      getter = () => {\n        if (cleanup) {\n          pauseTracking();\n          try {\n            cleanup();\n          } finally {\n            resetTracking();\n          }\n        }\n        const currentEffect = activeWatcher;\n        activeWatcher = effect;\n        try {\n          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);\n        } finally {\n          activeWatcher = currentEffect;\n        }\n      };\n    }\n  } else {\n    getter = NOOP;\n    !!(process.env.NODE_ENV !== \"production\") && warnInvalidSource(source);\n  }\n  if (cb && deep) {\n    const baseGetter = getter;\n    const depth = deep === true ? Infinity : deep;\n    getter = () => traverse(baseGetter(), depth);\n  }\n  const scope = getCurrentScope();\n  const watchHandle = () => {\n    effect.stop();\n    if (scope && scope.active) {\n      remove(scope.effects, effect);\n    }\n  };\n  if (once && cb) {\n    const _cb = cb;\n    cb = (...args) => {\n      _cb(...args);\n      watchHandle();\n    };\n  }\n  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;\n  const job = (immediateFirstRun) => {\n    if (!(effect.flags & 1) || !effect.dirty && !immediateFirstRun) {\n      return;\n    }\n    if (cb) {\n      const newValue = effect.run();\n      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {\n        if (cleanup) {\n          cleanup();\n        }\n        const currentWatcher = activeWatcher;\n        activeWatcher = effect;\n        try {\n          const args = [\n            newValue,\n            // pass undefined as the old value when it's changed for the first time\n            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,\n            boundCleanup\n          ];\n          call ? call(cb, 3, args) : (\n            // @ts-expect-error\n            cb(...args)\n          );\n          oldValue = newValue;\n        } finally {\n          activeWatcher = currentWatcher;\n        }\n      }\n    } else {\n      effect.run();\n    }\n  };\n  if (augmentJob) {\n    augmentJob(job);\n  }\n  effect = new ReactiveEffect(getter);\n  effect.scheduler = scheduler ? () => scheduler(job, false) : job;\n  boundCleanup = (fn) => onWatcherCleanup(fn, false, effect);\n  cleanup = effect.onStop = () => {\n    const cleanups = cleanupMap.get(effect);\n    if (cleanups) {\n      if (call) {\n        call(cleanups, 4);\n      } else {\n        for (const cleanup2 of cleanups) cleanup2();\n      }\n      cleanupMap.delete(effect);\n    }\n  };\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    effect.onTrack = options.onTrack;\n    effect.onTrigger = options.onTrigger;\n  }\n  if (cb) {\n    if (immediate) {\n      job(true);\n    } else {\n      oldValue = effect.run();\n    }\n  } else if (scheduler) {\n    scheduler(job.bind(null, true), true);\n  } else {\n    effect.run();\n  }\n  watchHandle.pause = effect.pause.bind(effect);\n  watchHandle.resume = effect.resume.bind(effect);\n  watchHandle.stop = watchHandle;\n  return watchHandle;\n}\nfunction traverse(value, depth = Infinity, seen) {\n  if (depth <= 0 || !isObject(value) || value[\"__v_skip\"]) {\n    return value;\n  }\n  seen = seen || /* @__PURE__ */ new Set();\n  if (seen.has(value)) {\n    return value;\n  }\n  seen.add(value);\n  depth--;\n  if (isRef(value)) {\n    traverse(value.value, depth, seen);\n  } else if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      traverse(value[i], depth, seen);\n    }\n  } else if (isSet(value) || isMap(value)) {\n    value.forEach((v) => {\n      traverse(v, depth, seen);\n    });\n  } else if (isPlainObject(value)) {\n    for (const key in value) {\n      traverse(value[key], depth, seen);\n    }\n    for (const key of Object.getOwnPropertySymbols(value)) {\n      if (Object.prototype.propertyIsEnumerable.call(value, key)) {\n        traverse(value[key], depth, seen);\n      }\n    }\n  }\n  return value;\n}\n\nexport { ARRAY_ITERATE_KEY, EffectFlags, EffectScope, ITERATE_KEY, MAP_KEY_ITERATE_KEY, ReactiveEffect, ReactiveFlags, TrackOpTypes, TriggerOpTypes, WatchErrorCodes, computed, customRef, effect, effectScope, enableTracking, getCurrentScope, getCurrentWatcher, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, onEffectCleanup, onScopeDispose, onWatcherCleanup, pauseTracking, proxyRefs, reactive, reactiveReadArray, readonly, ref, resetTracking, shallowReactive, shallowReadArray, shallowReadonly, shallowRef, stop, toRaw, toReactive, toReadonly, toRef, toRefs, toValue, track, traverse, trigger, triggerRef, unref, watch };\n","//h函数的基本使用：第一个参数不一定为根组件而是元素，第二个参数是包含一些属性的对象，第三个参数为渲染的子内容（可能是文本/元素/自内容数组）\n//h(\"div\", { style: { color: \"red\" }, onClick: fn }, `hello ${proxy.state.age}`)\nimport { isArray, isObject, isString, ShapeFlags } from \"@vue/shared\";\n// 生成vnode\nexport const createVNode = (type, props, children = null) => {\n    // console.log(rootComponent, rootProps);\n  \n    // 区分是组件的虚拟dom还是元素的虚拟dom\n    // 如果是字符串，说明是是一个普通的 HTML 元素节点；如果不是字符串且是一个对象，说明是一个组件（这里简化处理，直接默认有状态组件）\n    let shapeFlag = isString(type)\n      ? ShapeFlags.ELEMENT\n      : isObject(type)\n      ? ShapeFlags.STATEFUL_COMPONENT\n      : 0;\n    const vnode = {\n      _v_isVNode: true, //表示是一个虚拟dom\n      type,\n      props,\n      children,\n      key: props && props.key, // 后面的diff算法会用到\n      el: null, // 虚拟dom对应的真实dom\n      shapeFlag,\n    };\n    // 儿子标识\n    normalizeChildren(vnode, children);\n    return vnode;\n  };\n  \n  function normalizeChildren(vnode, children) {\n    let type = 0;\n    if (children === null) {\n    } else if (isArray(children)) {\n      // 说明该虚拟节点包含数组形式的子节点\n      type = ShapeFlags.ARRAY_CHILDREN;\n    } else {\n      // 简化处理，表示该虚拟节点包含纯文本子节点\n      type = ShapeFlags.TEXT_CHILDREN;\n    }\n    //位运算（按位或 |）按位或操作会对 两个数字的二进制每一位进行比较：只要其中 有一位是 1，结果就为 1。只有两个位都为 0，结果才是 0。\n    vnode.shapeFlag = vnode.shapeFlag | type; // 可能标识会受儿子影响\n  }\n  \n  export function isVnode(vnode) {\n    return vnode._v_isVNode;\n  }\n  \n  // 元素的chldren变成vnode\n  export const TEXT = Symbol(\"text\");\n  export function CVnode(child) {\n    if (isObject(child)) {\n      return child;\n    } else {\n      return createVNode(TEXT, null, String(child));\n    }\n  }\n\n","import { createVNode } from \"./vnode\";\n\n// apiCreateApp是起到将组件变成虚拟dom的作用（返回一个对象，对象具有mount挂载方法，该挂载方法做了两件事：1、生成vnode；2、render渲染vnode）\nexport function apiCreateApp(render) {\n  // createApp方法用于指明渲染的组件以及上面的属性\n  return function createApp(rootComponent, rootProps) {\n    let app = {\n      // 添加相关的属性\n      _components: rootComponent,\n      _props: rootProps,\n      _container: null,\n      mount(container) {\n        // 挂载的位置\n        // console.log(renderOptionDom, rootComponent, rootProps, container);\n        // 1、创建虚拟dom vnode\n        //vnode 是 虚拟 DOM 节点（virtual DOM node）的缩写。\n        //本质上是一个用 JavaScript 对象描述 DOM 结构的数据结构，也就是用 JS 模拟真实 DOM 树的结构。\n        let vnode = createVNode(rootComponent, rootProps);\n        //console.log(vnode);\n        // 2、将虚拟dom渲染到实际的位置\n        render(vnode, container);\n        app._container = container;\n      },\n    };\n    return app;\n  };\n}\n\n\n\n","import { hasOwn } from \"@vue/shared\";\r\n\r\n// 处理组件实例代理时的配置对象\r\nexport const componentPublicInstance = {\r\n  // target即{ _: instance }\r\n  get({ _: instance }, key) {\r\n    // 获取值的时候返回正确的结果，如proxy.xxx==>proxy.props.xxx\r\n    const { props, data, setupState } = instance;\r\n    if (key[0] === \"$\") {\r\n      // 表示该属性不能获取\r\n      return;\r\n    }\r\n    if (hasOwn(props, key)) {\r\n      return props[key];\r\n    } else if (hasOwn(setupState, key)) {\r\n      return setupState[key];\r\n    }\r\n  },\r\n  set({ _: instance }, key, value) {\r\n    const { props, data, setupState } = instance;\r\n\r\n    if (hasOwn(props, key)) {\r\n      props[key] = value;\r\n    } else if (hasOwn(setupState, key)) {\r\n      setupState[key] = value;\r\n    }\r\n  },\r\n};","import { extend, isFunction, isObject, ShapeFlags } from \"@vue/shared\";\r\nimport { componentPublicInstance } from \"./componentPublicInstance\";\r\n\r\n// 创建组件实例\r\nexport const createComponentInstance = (vnode) => {\r\n// instance本质是一个对象(包含组件的vnode，前面实现的组件的一些属性如参数props、自定义属性attrs，setup入口函数的状态等)\r\nconst instance = {\r\n  vnode,\r\n  type: vnode.type, // 组件的所有属性都在这里面\r\n  props: {}, // 组件的参数\r\n  attrs: {}, // 自定义属性\r\n  setupState: {}, // 用来存储setup入口函数的返回值\r\n  //ctx是渲染上下文\r\n  ctx: {}, // 用来处理代理，保存实例的值，和下面的proxy一起用。没有这个会导致用类似instance.props.xxx才能获取属性，有了之后直接proxy.xxx便能直接获取了\r\n  proxy: {}, // 和上面的ctx一起用\r\n  render: false, // 存储组件实例的渲染函数\r\n  isMounted: false, // 是否挂载\r\n};\r\n//这个语句的重点是：给 instance.ctx 赋一个对象，这个对象里有一个键 _，它的值是 instance 本身。\r\ninstance.ctx = { _: instance };//是一个 Vue 内部的约定写法，表示 “这个上下文来自哪个组件实例”\r\nreturn instance;\r\n};\r\n\r\n// 解析数据到该组件实例\r\nexport const setupComponet = (instance) => {\r\n  // 代理\r\n  instance.proxy = new Proxy(instance.ctx, componentPublicInstance as any);\r\n\r\n  // 拿到值（上面instance的props等）\r\n  const { props, children } = instance.vnode;\r\n  // 把值设置到组件实例上\r\n  instance.props = props;\r\n  instance.children = children; // 相当于slot插槽\r\n  // 看一下这个组件有无状态（有状态代表有setup入口函数或者render函数）\r\n  const shapeFlag = instance.vnode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT;\r\n  if (shapeFlag) {\r\n    setupStateComponent(instance);\r\n  } else {\r\n    // 如果无状态，说明是简单组件，直接渲染即可。\r\n  }\r\n};\r\n\r\n\r\n// 处理有状态的组件\r\nfunction setupStateComponent(instance) {\r\n    // setup方法的返回值是我们的render函数的参数\r\n    // 拿到组件的setup方法\r\n    //   其中我们可以知道：\r\n    // 1、setup方法的参数是组件参数props、上下文对象context（包含了父组件传递下来的非 prop 属性attrs、可以用来触发父组件中绑定的事件函数emit、一个指向当前组件实例的引用root、用来获取插槽内容的函数slot等）\r\n    // 2、setup方法的返回值可以是一个对象（包含代理的响应式属性以供渲染函数使用），也可以是直接返回渲染函数\r\n    const Component = instance.type; // createVNode时传入给type的是rootComponent，本质是一个对象，组件的所有属性都在这里，比如setup方法，比如render方法\r\n    const { setup } = Component;\r\n    //处理参数\r\n    //const setupContext = createContext(instance); // 返回一个上下文对象\r\n    //setup(instance.props, setupContext); // 实际执行的setup函数（实参）\r\n\r\n    //instance.proxy = new Proxy(instance.ctx, componentPublicInstance as any);\r\n\r\n    if (setup) {\r\n        const setupContext = createContext(instance); // 返回一个上下文对象\r\n        //调用组件定义中的 setup 函数，传入 props 和上下文\r\n        const setupResult = setup(instance.props, setupContext); // 实际执行的setup函数（实参）\r\n        // setup返回值有两种情况：1、对象；2、函数==>根据不同情况进行处理\r\n        // 如果是对象，则将值放在instance.setupState；如果是函数，则就是render函数\r\n        handlerSetupResult(instance, setupResult); \r\n      } else {\r\n        // 没有setup则会有instance.type.render方法的（处理无setup有render的情况）\r\n        finishComponentSetup(instance); // 通过vnode拿到render方法\r\n      }\r\n      \r\n}\r\n\r\n\r\n// 处理context上下文对象（包含了父组件传递下来的非 prop 属性attrs、可以用来触发父组件中绑定的事件函数emit、一个指向当前组件实例的引用root、用来获取插槽内容的函数slot等）\r\nfunction createContext(instance) {\r\n  return {\r\n    sttrs: instance.attrs,\r\n    slots: instance.slots,\r\n    emit: () => {},\r\n    expose: () => {},\r\n  };\r\n}\r\n\r\n// 处理setup函数的返回结果\r\nfunction handlerSetupResult(instance, setupResult) {\r\n    if (isFunction(setupResult)) {\r\n      instance.render = setupResult; // 处理有setup且返回函数的情况==>没必要使用组件的render方法了\r\n    } else if (isObject(setupResult)) {\r\n        //setupState是vue组件实例instance中用于存储setup()返回对象中的状态的属性\r\n      instance.setupState = setupResult; // 处理有setup且返回对象的情况==>要使用组件的render方法了\r\n    }\r\n  \r\n    // 最终也会走render（把render挂载到实例上去）\r\n    finishComponentSetup(instance);\r\n  }\r\n\r\n// 处理render（把render挂载到实例上去）\r\nfunction finishComponentSetup(instance) {\r\n    // 判断组件中有没有render方法，没有则\r\n    const Component = instance.type; // createVNode时传入给type的是rootComponent，本质是一个对象，组件的所有属性都在这里，比如setup方法，比如render方法\r\n    if (!instance.render) {\r\n      // 这里的render指的是上面instance实例的render属性，在handlerSetupResult函数中会赋值（赋值的情况：组件有setup且返回函数），如果没有setup则此时会为false，则需要赋组件的render方法\r\n      //template 是 HTML 字符串。Vue 会用它的模板编译器（@vue/compiler-dom）把它编译成 JS 渲染函数。\r\n      if (!Component.render && Component.template) {\r\n        // TODO：模版编译\r\n      }\r\n      instance.render = Component.render;\r\n    }\r\n    //console.log(instance.render);\r\n  }\r\n  \r\n  \r\n\r\n    ","//import { ShapeFlags } from \"@vue/shared\";\n//import { effect } from \"@vue/reactivity\";\n//import { apiCreateApp } from \"./apiCreateApp\";\n//import { createComponentInstance, setupComponet } from \"./component\";\n//\n//  // 实现渲染Vue3组件==>vnode==>render\n//export function createRender(renderOptionDom) {\n//\n//  const processComponent = (n1, n2, container) => {//负责处理组件的渲染（初次渲染和更新两种情况）\n//    if (n1 === null) {\n//      // 组件第一次加载\n//      mountComponent(n2, container);\n//    } else {\n//      // 更新\n//    }\n//  };\n//\n//  // 组件渲染的真正方法（实现由虚拟dom变成真实dom），步骤（核心）：\n//const mountComponent = (InitialVnode, container) => {\n//  //InitialVnode是当前要挂载的虚拟节点\n//  // 1、先有一个组件的实例对象（即Vue3组件渲染函数render传入的第一个参数proxy，其实proxy参数将组件定义的所有属性合并了，等效于在setup入口函数里面返回一个函数，可以用proxy.来获取属性）\n//  const instanece = (InitialVnode.component =//InitialVnode.component是指当前组件虚拟节点所关联的组件实例对象\n//    //createComponentInstance会基于当前虚拟节点 InitialVnode 创建一个组件实例对象（包含 props、setup 返回值、render 函数等）\n//    createComponentInstance(InitialVnode)); // 记得在weak-vue\\packages\\runtime-core\\src\\vnode.ts文件给vnode定义中加上这个属性\n//    //↑vnode.component 本来是 null，你需要手动创建一个组件实例对象并挂载回 vnode.component，\n//  // 2、解析数据到这个实例对象中\n//  setupComponet(instanece);\n//  // 3、创建一个effect让render函数执行\n//  setupRenderEffect(instanece);\n//};\n//\n//// 创建一个effect让render函数执行(响应式)\n//function setupRenderEffect(instance) {\n//  // 创建effect(原理可以回前面的内容找)\n//  //effect作用： 收集副作用函数，当依赖的数据发生变化时，这个副作用函数就会重新执行。\n//  //componentEffect() 是副作用函数，也就是渲染函数。每次响应式数据变了，它都会重新调用。\n//  effect(function componentEffect() {\n//    // 判断是否是初次渲染\n//    if (!instance.isMounted) {//isMounted是一个标志属性，用来 标识当前组件是否已经挂载过（即是否是第一次渲染）。\n//      // 获取到render返回值\n//      const proxy = instance.proxy; // 已经代理了组件，可以访问到组件的所有属性和所有方法\n//      //.call(proxy, proxy) 的意思是：用 proxy 来作为 this，也作为参数传进去。这样写可以确保在 render 函数中可以写成 this.xxx 或直接访问 proxy.xxx。\n//      // render函数执行，即调用render函数，第一个参数表示render函数的this指向组件实例proxy，第二个参数表示执行render函数的参数也是proxy\n//    \n//      const subTree = instance.render.call(proxy, proxy);\n//      console.log(\"h函数生成的vnode树：\", subTree);\n//    }\n//\n//  });\n//}\n//\n//\n//  \n//  // patch函数负责根据vnode的不同情况（组件、元素）来实现对应的渲染\n//const patch = (n1, n2, container) => {\n//  // 针对不同的类型采取不同的渲染方式（vnode有一个shapeFlag标识来标识组件/元素）\n//  const { shapeFlag } = n2;\n//  // 等效于shapeFlag && shapeFlag === ShapeFlags.ELEMENT\n//  //因为一个vnode可以有多个类型，比如是元素，又有子元素，不能只用===判断唯一性，要用位运算表示多个特征\n//  //按位与:两个数的对应位都为 1，结果才是 1，否则就是 0\n//  if (shapeFlag & ShapeFlags.ELEMENT) {//判断 shapeFlag 是否包含 ShapeFlags.ELEMENT 这个标志。它返回一个数字，若结果不为 0，则说明包含。\n//    // 处理元素\n//    // console.log(\"元素\");\n//  } else if (shapeFlag & ShapeFlags.STATEFUL_COMPONENT) {\n//    // 处理组件\n//    processComponent(n1, n2, container);\n//  }\n//};\n//  // 真正实现渲染的函数（渲染vnode)\n//  let render = (vnode, container) => {\n//        // 第一次渲染（三个参数：旧的节点、当前节点、位置）\n//        patch(null, vnode, container);\n//  };\n//\n///** ---------------处理元素--------------- */\n//const processElement = (n1, n2, container) => {\n//  if (n1 === null) {\n//    // 元素第一次挂载\n//    mountElement(n2, container);\n//  } else {\n//    // 更新\n//  }\n//};\n//\n//const mountElement = (vnode, container) => {\n//  // 递归渲染子节点==>dom操作==》挂载到container/页面上\n//  const { shapeFlag, props, type, children } = vnode;\n//  // 1、创建元素--记得把真实dom挂载到vnode上，方便后面更新时使用\n//  let el = (vnode.el = hostCreateElement(type));\n//  // 2、创建元素的属性\n//  if (props) {\n//    for (const key in props) {\n//      hostPatchProp(el, key, null, props[key]);\n//    }\n//  }\n//  // 3、放入到对应的容器中\n//  hostInsert(el, container);\n//};\n//\n//\n//\n//\n//  // 返回一个具有createApp方法的对象，其中createApp负责生成一个具有mount挂载方法的app对象（包含属性、方法等），进而实现1、生成vnode；2、render渲染vnode\n//  return {\n//    createApp: apiCreateApp(render),\n//  };\n//\n//}\n//\n//\n//\n\n\nimport { ShapeFlags } from \"@vue/shared\";\nimport { effect } from \"@vue/reactivity\";\nimport { apiCreateApp } from \"./apiCreateApp\";\nimport { createComponentInstance, setupComponet } from \"./component\";\nimport { CVnode, TEXT } from \"./vnode\";\n\n// 实现渲染Vue3组件==>vnode==>render\nexport function createRender(renderOptionDom) {\n  // 获取所有的dom操作\n  const {\n    insert: hostInsert,\n    remove: hostRemove,\n    patchProps: hostPatchProp,\n    createElement: hostCreateElement,\n    createText: hostCreateText,\n    createComment: hostCreateComment,\n    setText: hostSetText,\n    setElementText: hostSetElementText,\n  } = renderOptionDom;\n\n  // 创建一个effect让render函数执行(响应式)\n  const setupRenderEffect = (instance, container) => {\n    // 创建effect(原理可以回前面的内容找)\n    effect(function componentEffect() {\n      // 判断是否是初次渲染\n      if (!instance.isMounted) {\n        // 获取到render返回值\n        const proxy = instance.proxy; // 已经代理了组件，可以访问到组件的所有属性和所有方法\n        // console.log(\"这是组件实例proxy：\");\n        // console.log(proxy);\n        const subTree = instance.render.call(proxy, proxy); // render函数执行，即调用render函数，第一个参数表示render函数的this指向组件实例proxy，第二个参数表示执行render函数的参数也是proxy\n        // console.log(\"h函数生成的vnode树：\", subTree);\n        patch(null, subTree, container); // 渲染vnode（此时是元素的vnode）\n      }\n    });\n  };\n\n  /** ---------------处理组件--------------- */\n  // 组件的创建方法（分为初次渲染和更新两种情况）\n  const processComponent = (n1, n2, container) => {\n    if (n1 === null) {\n      // 组件第一次加载\n      mountComponent(n2, container);\n    } else {\n      // 更新\n    }\n  };\n  // 组件渲染的真正方法（实现由虚拟dom变成真实dom），步骤（核心）：\n  const mountComponent = (InitialVnode, container) => {\n    // 1、先有一个组件的实例对象（即Vue3组件渲染函数render传入的第一个参数proxy，其实proxy参数将组件定义的所有属性合并了，等效于在setup入口函数里面返回一个函数，可以用proxy.来获取属性）\n    const instanece = (InitialVnode.component =\n      createComponentInstance(InitialVnode)); // 记得在Vue3.0\\packages\\runtime-core\\src\\vnode.ts文件给vnode定义中加上这个属性\n    // 2、解析数据到这个实例对象中\n    setupComponet(instanece);\n    // 3、创建一个effect让render函数执行\n    setupRenderEffect(instanece, container);\n  };\n\n  /** ---------------处理元素--------------- */\n  const processElement = (n1, n2, container) => {\n    if (n1 === null) {\n      // 元素第一次挂载\n      mountElement(n2, container);\n    } else {\n      // 更新\n    }\n  };\n  // 元素的渲染方法\n  const mountElement = (vnode, container) => {\n    // 递归渲染子节点==>dom操作==》挂载到container/页面上\n    const { shapeFlag, props, type, children } = vnode;\n    // 1、创建元素\n    let el = hostCreateElement(type);\n    // 2、创建元素的属性\n    if (props) {\n      for (const key in props) {\n        hostPatchProp(el, key, null, props[key]);\n      }\n    }\n    // 3、处理children\n    if (children) {\n      if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\n        console.log(\"这是文本字符串形式子节点：\", children);\n        hostSetElementText(el, children); // 文本形式子节点，比如这种情况：h('div',{},'张三')，将children直接插入到el中\n      } else if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n        // 递归渲染子节点\n        console.log(\"这是数组形式子节点：\", children);\n        mountChildren(el, children); // 数组形式子节点，比如这种情况：h('div',{},['张三',h('p',{},'李四')])，将children递归渲染插入到el中\n      }\n    }\n    // 4、放入到对应的容器中\n    hostInsert(el, container);\n  };\n  // 递归渲染子节点\n  const mountChildren = (container, children) => {\n    for (let i = 0; i < children.length; i++) {\n      // children[i]两种情况：1、['张三']这种元素，字符串的形式；2、h('div',{},'张三')这种元素，对象的形式（vnode）\n      // 但两种情况都需要转换成vnode来处理，方便借助patch函数来渲染\n      const child = CVnode(children[i]); // 第一种情况转换成vnode\n      // 递归渲染子节点（vnode包含了元素、组件、文本三种情况）\n      patch(null, child, container);\n    }\n  };\n\n  /** ---------------处理文本--------------- */\n  const processTxt = (n1, n2, container) => {\n    if (n1 === null) {\n      // 创建文本==>直接渲染到页面中（变成真实dom==>插入）\n      hostInsert(hostCreateText(n2.children), container);\n    } else {\n      // 更新\n    }\n  };\n\n  /**---------------------------------------------------------- */\n\n  // patch函数负责根据vnode的不同情况（组件、元素、文本）来实现对应的渲染\n  const patch = (n1, n2, container) => {\n    // 针对不同的类型采取不同的渲染方式（vonode有一个shapeFlag标识来标识组件/元素）\n    const { shapeFlag, type } = n2;\n    switch (type) {\n      case TEXT:\n        // 处理文本\n        processTxt(n1, n2, container);\n        break;\n      default:\n        // 等效于shapeFlag && shapeFlag === ShapeFlags.ELEMENT\n        if (shapeFlag & ShapeFlags.ELEMENT) {\n          // 处理元素(h函数)\n          // console.log(\"此时处理的是元素！！！\");\n          processElement(n1, n2, container);\n        } else if (shapeFlag & ShapeFlags.STATEFUL_COMPONENT) {\n          // 处理组件\n          processComponent(n1, n2, container);\n        }\n    }\n  };\n\n  // 真正实现渲染的函数（渲染vnode)\n  const render = (vnode, container) => {\n    // 第一次渲染（三个参数：旧的节点、当前节点、位置）\n    patch(null, vnode, container);\n  };\n\n  // 返回一个具有createApp方法的对象，其中createApp负责生成一个具有mount挂载方法的app对象（包含属性、方法等），进而实现1、生成vnode；2、render渲染vnode\n  return {\n    createApp: apiCreateApp(render),\n  };\n}\n\n","// h函数的作用==>生成vnode（createVNode原理可以回去前面的内容看），核心之一==>处理参数\r\nimport { isObject,isArray } from \"@vue/shared\";\r\nimport { createVNode,isVnode } from \"./vnode\";\r\n\r\nexport function h(type, propsOrChildren, children) {\r\n    // 先根据参数个数来处理\r\n    const i = arguments.length;\r\n    if (i === 2) {\r\n      // 情况1：元素+属性(传入一个对象)\r\n      if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {\r\n        //h(\"div\", vnode)\tvnode 作为子节点\tcreateVNode(type, null, [vnode])\r\n        //h(\"div\", [vnode])\tvnode数组作为 children\tcreateVNode(type, null, propsOrChildren)\r\n        if (isVnode(propsOrChildren)) {\r\n          // h(\"div\", vnode)\r\n          // 是vnode，不是属性\r\n          return createVNode(type, null, [propsOrChildren]);\r\n        }\r\n        //是普通对象=>是props\r\n        // h(\"div\", { id: 'app' })\r\n        return createVNode(type, propsOrChildren); // 没有儿子\r\n      } else {\r\n        // 情况2：元素+children\r\n        // h(\"div\", 'hello') 或 h(\"div\", [vnode, vnode])\r\n        return createVNode(type, null, propsOrChildren);\r\n      }\r\n    } else {\r\n      if (i > 3) {\r\n        children = Array.prototype.slice.call(arguments, 2); // 第二个参数后面的所有参数，都应该放在children数组里面\r\n      } else if (i === 3 && isVnode(children)) {//h(\"div\", { id: \"box\" }, h(\"span\"))，第三个参数是一个vnode，是一个子节点而不是数组\r\n        children = [children];//把vnode包装成一个数组\r\n      }\r\n      return createVNode(type, propsOrChildren, children);\r\n    }\r\n  }\r\n  \r\n\r\n\r\n\r\n"],"names":[],"mappings":"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","x_google_ignoreList":[0]}
{"version":3,"file":"runtime-dom.global.js","sources":["../../shared/src/general.ts","../../shared/src/shapeFlags.ts","../../shared/src/index.ts","../src/nodeOps.ts","../src/modules/class.ts","../src/modules/style.ts","../src/modules/attrt.ts","../src/modules/event.ts","../src/patchProp.ts","../../runtime-core/src/vnode.ts","../../runtime-core/src/apiCreateApp.ts","../../runtime-core/src/componentPublicInstance.ts","../../runtime-core/src/component.ts","../../runtime-core/src/apilifecycle.ts","../../runtime-core/src/render.ts","../src/index.ts"],"sourcesContent":["/**公共方法 */\n// 判断是否为对象\nexport const isObject = (target) =>\n    typeof target === \"object\" && target !== null;//因为 typeof null 也是 \"object\"，需要排除它。\nexport const isArray = Array.isArray;\nexport const isFunction = (val) => typeof val === \"function\";\nexport const isString = (val) => typeof val === \"string\";\nexport const isNumber = (val) => typeof val === \"number\";\n// 合并两个对象\nexport const extend = Object.assign;//直接将 ES 的 Object.assign() 方法赋值为 extend 名称\n  \n// 判断对象是否有某个属性（两个参数，返回值为布尔型，key is keyof typeof val使用了ts的类型守卫语法）\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n//下面这个函数；函数名是hasOwn，参数是val和key，): key is keyof typeof val =>是箭头函数的返回类型注解；真正的函数体是箭头后面的\nexport const hasOwn = (\n  val: object,\n  key: string | symbol //第二个参数叫key，可以是字符串或Symbol类型\n): key is keyof typeof val => hasOwnProperty.call(val,key);\n//typeof val：获取变量 val 的类型，相当于：name:string;age:number\n//keyof typeof val:表示这个对象类型的所有“键名”组成的联合类型：type KeyType = \"name\" | \"age\";\n//总体意思:如果函数返回true,那我保证这个key就是val对象的一个有效键\n//这里的.call()作用是改变函数执行时候的this指向\n  //例子：const obj = Object.create(null)\n        //obj.name = '李四'\n        //obj.hasOwnProperty('name') // ❌ 报错！\n        //Object.prototype.hasOwnProperty.call(obj, 'name') // ✅ true\n\n\n// 判断数组的key是否是整数\n// 数组经过proxy代理之后，会变成对象的形式，如console.log(new Proxy([1,2,3],{})); ===》Proxy(Array) {'0': 1, '1': 2, '2': 3}（js对象的key类型为字符串），因此\"\" + parseInt(key, 10)这样是为了方便拿到正确的字符串key用于判断\n// console.log(Array.isArray(new Proxy([1,2,3],{})))===》true\n// 比如此时arr[2]=4，应该是\nexport const isIntegerKey = (key) => {\n  isString(key) &&\n    key !== \"NaN\" &&\n    key[0] !== \"-\" &&\n    \"\" + parseInt(key, 10) === key;//只有当 key 是纯数字字符串，并且没有多余字符（如前导零、单位 px、字母等）时，这个表达式才为 true。\n    //parseInt(key, 10)：把 key 转换为整数（忽略后面非数字字符）。\n    //\"\" + ...：把解析出来的数字 转成字符串。\n    //\"\" + parseInt(key, 10)即(比如\"08\"->8->\"8\")\n};\n\n// 判断值是否更新\nexport const hasChange = (value, oldValue) => value !== oldValue;\n\n// 创建map映射关系\nexport function makeMap(\n  str: string, //如\"div,span,p\"\n  expectsLowerCase?: boolean //是否在判断时把传入的key转为小写\n): (key: string) => boolean { //makeMap 这个函数会返回一个函数，这个函数： 接收一个字符串参数 key: string；返回一个布尔值 boolean\n  const set = new Set(str.split(\",\")); //拆分字符串，变成数组（split），然后用Set储存成集合\n  return expectsLowerCase\n    ? (val) => set.has(val.toLowerCase()) //转小写\n    : (val) => set.has(val);\n}\n\n","//在vnode.ts生成虚拟DOM节点中，第一个参数 type 不一定为根组件也可能是元素，生成的虚拟 dom 也要据此做出区分。\n//至于怎么区分，源码里面为了精确地获取节点的特性信息的同时提高渲染性能，借助了枚举，每个枚举值都是一个二进制位掩码\n//至于为什么用二进制源码表示，这是因为经过大量的实践证明，二进制表示、位运算可以节省内存空间的同时大大优化对比性能，同时也可以方便组合、提高代码简洁度，可以用于标记虚拟节点的具体类型和特性\n\nexport enum ShapeFlags {\n    ELEMENT = 1, // 表示该虚拟节点是一个普通的 HTML 元素节点\n    FUNCTIONAL_COMPONENT = 1 << 1, // 表示该虚拟节点是一个函数式组件节点\n    STATEFUL_COMPONENT = 1 << 2, // 表示该虚拟节点是一个有状态的组件节点\n    //为 TEXT_CHILDREN 这个标志位分配一个唯一的 二进制位，具体值是 1 左移 3 位\n    TEXT_CHILDREN = 1 << 3, // 表示该虚拟节点包含纯文本子节点\n    ARRAY_CHILDREN = 1 << 4, // 表示该虚拟节点包含数组形式的子节点\n    SLOTS_CHILDREN = 1 << 5, // 表示该虚拟节点包含插槽形式的子节点\n    TELEPORT = 1 << 6, // 表示该虚拟节点是一个传送门（Teleport）节点\n    SUSPENSE = 1 << 7, // 表示该虚拟节点是一个异步加载（Suspense）节点\n    COMPONENT_SHOULD_KEEP_ALIVE = 1 << 8, // 表示该虚拟节点的组件应该被缓存而不是销毁\n    COMPONENT_KEPT_ALIVE = 1 << 9, // 表示该虚拟节点的组件已被缓存\n    COMPONENT = ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT, // 表示该虚拟节点是一个组件节点，可以是函数式组件或者有状态的组件\n  }\n  \n","export * from \"./general\";\nexport {ShapeFlags} from \"./shapeFlags\";\nimport { ShapeFlags } from './shapeFlags'\nconsole.log(ShapeFlags);\n","// 操作节点（增删改查）\nexport const nodeOps = {\n    // 对节点的一些操作\n    // 创建元素，createElement(runtime-dom本质是运行时操作dom，但因为每个平台操作dom的方法不同，vue的runtime-dom模块的createElement方法是针对浏览器的)\n    createElement: (tagName) => document.createElement(tagName),\n    // 删除元素\n    remove: (child) => {\n      const parent = child.parentNode;\n      if (parent) {\n        parent.removeChild(child);\n      }\n    },\n    // 插入元素\n    //anchor表示插入的位置锚点，要插入的内容再这个的前面\n    //anchor为空的时候，insert(p1,parent,null)就相当于parent.appendChild(p1)\n    insert: (child, parent, ancher = null) => {\n        //insertBefore函数：两个参数：newNode和referenceNode,前者代表想要插入/加进去的元素，后者代表插入位置的参照节点，newNode会被插到它之前\n      parent.insertBefore(child, ancher); // anchor为空相当于appendchild\n    },\n    // 选择节点\n    querySelector: (select) => document.querySelector(select),\n    // 设置节点的文本\n    setElementText: (el, text) => {\n      el.textContent = text;\n    },\n  \n    // 对文本的一些操作\n    createText: (text) => document.createTextNode(text),\n    setText: (node, text) => (node.nodeValue = text),\n  };\n  ","// 处理class\nexport const patchClass = (el, value) => {\n    // 对这个标签的class赋值（如果没有赋值为空，如果有则直接打点获取属性后覆盖）\n    if (value === null) {\n      value = \"\";\n    }\n    el.className = value;\n  };\n  \n","// 处理style\n// 已经渲染到页面上{style：{color:'red'}}=>当前（新的）样式{style:{background:'green'，font-size:20px}}\nexport const patchStyle = (el, prev, next) => {\n    const style = el.style;\n  \n    // 说明样式删除\n\n    //新样式整体为 null（不是一个对象，而是整个没了）→ 意味着：元素彻底不需要任何样式了。所以干脆把整个 style 属性从 DOM 中删除（更彻底、更高效）。\n    if (next === null) {//如果新的样式next是null，说明这个元素不再需要样式了，就直接把原来的样式删掉\n      el.removeAttribute(\"style\");\n    } else {//next 是一个对象，但可能缺少某些字段（比如删了 color）。如果 prev 有 color: \"red\"，而 next.color === null，那就清掉这一条具体样式。只清除有差异的单个样式项。\n      // 如果是已经渲染的样式有某样式，但是新的样式没有，则要清除老的样式\n      if (prev) {\n        for (const key in prev) {\n          if (next[key] === null) {\n            style[key] = \"\";\n          }\n        }\n      }\n      // 如果是新的有，老的没有，则直接打点获取属性后覆盖\n      for (const key in next) {\n        style[key] = next[key];\n      }\n    }\n  };\n  \n","// 处理一些自定义的属性\nexport const patchAttr = (el, key, value) => {\n    if (value === null) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key,value);\n    }\n  };\n","// 注意：对事件的处理比较特殊，因为事件和样式类名自定义属性不一样，绑定不同的事件不能直接覆盖，如@click=\"fn1\"、@click = \"fn2\"。\n// 因为 addEventListener 重复添加事件监听时，不能替换之前的监听，导致有多个监听同时存在。\n// 所以这里借助一个 map 结构存储所有的事件映射，然后 addEventListener 监听对应的映射值，然后重复绑定时直接改变映射值即可（相当于改变引用）。\n\n// 源码对这个处理使用了缓存，用一个map结构存储元素key上面绑定的元素\n\n// el为元素，key是触发事件的方法，即事件名（如click），value为绑定的函数方法\nexport const patchEvent = (el, key, value) => {\n    //确保当前 DOM 元素 el 上有一个事件缓存对象 _vei，如果没有，就创建一个空对象 {}。\n    //el._vei 是挂在 DOM 元素上的自定义属性，用来缓存所有绑定在这个元素上的事件监听器。\n    //如果这个元素之前已经绑定过事件，el._vei 就已经存在，直接使用。如果这个元素还没有绑定过任何事件，就创建一个新的空对象，并赋值给 el._vei。\n\n    //el._vei存的是一个元素上所有事件的缓存对象，它记录了事件类型（如 click）和它对应的事件执行器（invoker）。\n    const invokers = el._vei || (el._vei = {}); // el._vei相当于一个元素的事件map缓存结构，可能为空{}。拿上面的例子来说的话，此时应该是{\"click\":{value:fn1}}\n    //如果之前就已经绑定了这个事件，exists 就是那个事件的处理器（invoker）\n    const exists = invokers[key]; // 拿上面的例子来说的话，此时应该是 {value:fn1}\n    if (exists && value) {//事件存在，并且传入了新的value\n      // 不能进行覆盖（情况1）==>改变缓存中的value指向最新的事件即可，相当于改变exists的fn引用\n      exists.value = value;//exists.value就是你最新绑定的事件处理函数\n    } else {\n      // 如果该触发方式还未绑定事件或者传入的函数为空，可能是新的绑定，也可能是清除事件\n      //下面这行代码的作用举例：从 \"onClick\" 得到 \"click\"，即浏览器认识的事件名\n      const eventName = key.slice(2).toLowerCase();//toLowerCase()是JavaScript 字符串的一个方法，用来将 字符串中的所有字母转换为小写。\n      if (value) {\n        //  新的事件绑定，且将该绑定放入缓存器（情况2）\n        //invokers是一个map对象\n        //把新创建的 invoker 缓存在 invokers 这个对象中，并使用事件名（如 \"click\"）作为 key，对应这个 invoker 作为 value。这样后续就可以通过事件名快速找到对应的 invoker，实现高效的事件管理。\n        let invoker = (invokers[eventName] = createInvoker(value)); // 返回一个包装后的函数\n        el.addEventListener(eventName, invoker);\n      } else {\n        //  移除事件（情况3）\n        //为什么下面这里使用的是exists 而不是 invokers[eventName]？\n        //因为上述变化中，exists = invokers[key]; // 注意 key 是 \"onClick\"；但是eventName是去掉了on并且变成小写了的click\n        el.removeEventListener(eventName, exists);\n        //补充：element.removeEventListener(type, listener, options);\n        // type: 事件类型（字符串），比如 'click'、'input' 等。listener: 要移除的事件处理函数（必须是同一个函数引用）。options: 可选参数（和 addEventListener 的第三个参数一样）。\n        invokers[eventName] = null;\n      }\n    }\n  };\n  \n  //尤其在 高效更新 的场景下，我们不希望每次更新事件处理时都重新绑定事件。为了实现这个高效更新的目标，Vue 采用了包装函数的方式，使得我们可以 动态更新事件处理函数，而不必解绑再重新绑定。\n  \n  //这个函数的目的是生成一个包装函数\n  function createInvoker(value) {\n    //value 就是你实际绑定的事件处理函数（比如 fn1 或 fn2）。\n    //invoker是一个包装函数，目的：让事件处理函数（即 value）通过 invoker 来触发，invoker 本身是一个函数，但是它是代理函数，调用它实际上是调用 invoker.value。\n    //invoker的任务是将事件参数传递给实际的事件处理函数。\n    // 为什么用他呢？如果事件处理函数（value）发生变化，我们不需要重新绑定事件，而是只需要更新 invoker.value。\n    const invoker = (e) => {//\n      invoker.value(e);\n    };\n    invoker.value = value;//这样传进去之后，invoker.value中存储了我们传入的事件处理函数（比如 fn1、fn2）。\n    //invoker.value 可以在后续的某个时刻被更新，这就意味着我们可以在不重新绑定事件的情况下，动态改变事件处理逻辑。\n    return invoker;\n  }\n  ","// 操作属性（增删改查）\nimport { patchClass } from \"./modules/class\";\nimport { patchStyle } from \"./modules/style\";\nimport { patchAttr } from \"./modules/attrt\";\nimport { patchEvent } from \"./modules/event\";\n//意思是：给某个 DOM 元素 el，根据属性名 key，把旧值 prevValue 更新为新值 nextValue。\nexport const patchProps = (el, key, prevValue, nextValue) => {\n  switch (key) {\n    case \"class\":\n      patchClass(el, nextValue); // 只用传节点和新的class值\n      //更新类名，不需要旧值参与\n      break;\n    case \"style\":\n      patchStyle(el, prevValue, nextValue);//会智能对比 prevValue 和 nextValue，只更新有变化的部分，删除不需要的旧样式。\n      break;\n    default:\n      // 事件要另外处理(事件的特征：@、onclick等==>正则匹配，如以on开头，后面跟小写字母，这里简化判断，知道思想即可)\n      //^ 在方括号内，表示否定，即“不属于这个范围”。\n      //[^a-z] - 排除小写字母\n      if (/^on[^a-z]/.test(key)) {\n        patchEvent(el, key, nextValue);\n      } else {\n        patchAttr(el, key, nextValue);\n      }\n  }\n};\n\n","//h函数的基本使用：第一个参数不一定为根组件而是元素，第二个参数是包含一些属性的对象，第三个参数为渲染的子内容（可能是文本/元素/自内容数组）\n//h(\"div\", { style: { color: \"red\" }, onClick: fn }, `hello ${proxy.state.age}`)\nimport { isArray, isObject, isString, ShapeFlags } from \"@vue/shared\";\n// 生成vnode\nexport const createVNode = (type, props, children = null) => {\n    // console.log(rootComponent, rootProps);\n  \n    // 区分是组件的虚拟dom还是元素的虚拟dom\n    // 如果是字符串，说明是是一个普通的 HTML 元素节点；如果不是字符串且是一个对象，说明是一个组件（这里简化处理，直接默认有状态组件）\n    let shapeFlag = isString(type)\n      ? ShapeFlags.ELEMENT\n      : isObject(type)\n      ? ShapeFlags.STATEFUL_COMPONENT\n      : 0;\n    const vnode = {\n      _v_isVNode: true, //表示是一个虚拟dom\n      type,\n      props,\n      children,\n      key: props && props.key, // 后面的diff算法会用到\n      el: null, // 虚拟dom对应的真实dom\n      shapeFlag,\n    };\n    // 儿子标识\n    normalizeChildren(vnode, children);\n    return vnode;\n  };\n  \n  function normalizeChildren(vnode, children) {\n    let type = 0;\n    if (children === null) {\n    } else if (isArray(children)) {\n      // 说明该虚拟节点包含数组形式的子节点\n      type = ShapeFlags.ARRAY_CHILDREN;\n    } else {\n      // 简化处理，表示该虚拟节点包含纯文本子节点\n      type = ShapeFlags.TEXT_CHILDREN;\n    }\n    //位运算（按位或 |）按位或操作会对 两个数字的二进制每一位进行比较：只要其中 有一位是 1，结果就为 1。只有两个位都为 0，结果才是 0。\n    vnode.shapeFlag = vnode.shapeFlag | type; // 可能标识会受儿子影响\n  }\n  \n  export function isVnode(vnode) {\n    return vnode._v_isVNode;\n  }\n  \n  // 元素的chldren变成vnode\n  export const TEXT = Symbol(\"text\");\n  export function CVnode(child) {\n    if (isObject(child)) {\n      return child;\n    } else {\n      return createVNode(TEXT, null, String(child));\n    }\n  }\n\n","import { createVNode } from \"./vnode\";\n\n// apiCreateApp是起到将组件变成虚拟dom的作用（返回一个对象，对象具有mount挂载方法，该挂载方法做了两件事：1、生成vnode；2、render渲染vnode）\nexport function apiCreateApp(render) {\n  // createApp方法用于指明渲染的组件以及上面的属性\n  return function createApp(rootComponent, rootProps) {\n    let app = {\n      // 添加相关的属性\n      _components: rootComponent,\n      _props: rootProps,\n      _container: null,\n      mount(container) {\n        // 挂载的位置\n        // console.log(renderOptionDom, rootComponent, rootProps, container);\n        // 1、创建虚拟dom vnode\n        //vnode 是 虚拟 DOM 节点（virtual DOM node）的缩写。\n        //本质上是一个用 JavaScript 对象描述 DOM 结构的数据结构，也就是用 JS 模拟真实 DOM 树的结构。\n        let vnode = createVNode(rootComponent, rootProps);\n        //console.log(vnode);\n        // 2、将虚拟dom渲染到实际的位置\n        render(vnode, container);\n        app._container = container;\n      },\n    };\n    return app;\n  };\n}\n\n\n\n","import { hasOwn } from \"@vue/shared\";\r\n\r\n// 处理组件实例代理时的配置对象\r\nexport const componentPublicInstance = {\r\n  // target即{ _: instance }\r\n  get({ _: instance }, key) {\r\n    // 获取值的时候返回正确的结果，如proxy.xxx==>proxy.props.xxx\r\n    const { props, data, setupState } = instance;\r\n    if (key[0] === \"$\") {\r\n      // 表示该属性不能获取\r\n      return;\r\n    }\r\n    if (hasOwn(props, key)) {\r\n      return props[key];\r\n    } else if (hasOwn(setupState, key)) {\r\n      return setupState[key];\r\n    }\r\n  },\r\n  set({ _: instance }, key, value) {\r\n    const { props, data, setupState } = instance;\r\n\r\n    if (hasOwn(props, key)) {\r\n      props[key] = value;\r\n    } else if (hasOwn(setupState, key)) {\r\n      setupState[key] = value;\r\n    }\r\n  },\r\n};","import { extend, isFunction, isObject, ShapeFlags } from \"@vue/shared\";\r\nimport { componentPublicInstance } from \"./componentPublicInstance\";\r\n\r\n// 获取到当前组件实例\r\nexport const getCurrentInstance = () => {\r\n  return currentInstance;\r\n};\r\n\r\n// 设置当前组件实例\r\nexport const setCurrentInstance = (target) => {\r\n  currentInstance = target;\r\n};\r\n\r\n\r\n// 创建组件实例\r\nexport const createComponentInstance = (vnode) => {\r\n// instance本质是一个对象(包含组件的vnode，前面实现的组件的一些属性如参数props、自定义属性attrs，setup入口函数的状态等)\r\nconst instance = {\r\n  vnode,\r\n  type: vnode.type, // 组件的所有属性都在这里面\r\n  props: {}, // 组件的参数\r\n  attrs: {}, // 自定义属性\r\n  setupState: {}, // 用来存储setup入口函数的返回值\r\n  //ctx是渲染上下文\r\n  ctx: {}, // 用来处理代理，保存实例的值，和下面的proxy一起用。没有这个会导致用类似instance.props.xxx才能获取属性，有了之后直接proxy.xxx便能直接获取了\r\n  proxy: {}, // 和上面的ctx一起用\r\n  render: false, // 存储组件实例的渲染函数\r\n  isMounted: false, // 是否挂载\r\n};\r\n//这个语句的重点是：给 instance.ctx 赋一个对象，这个对象里有一个键 _，它的值是 instance 本身。\r\ninstance.ctx = { _: instance };//是一个 Vue 内部的约定写法，表示 “这个上下文来自哪个组件实例”\r\nreturn instance;\r\n};\r\n\r\n// 解析数据到该组件实例\r\nexport const setupComponet = (instance) => {\r\n  // 代理\r\n  instance.proxy = new Proxy(instance.ctx, componentPublicInstance as any);\r\n\r\n  // 拿到值（上面instance的props等）\r\n  const { props, children } = instance.vnode;\r\n  // 把值设置到组件实例上\r\n  instance.props = props;\r\n  instance.children = children; // 相当于slot插槽\r\n  // 看一下这个组件有无状态（有状态代表有setup入口函数或者render函数）\r\n  const shapeFlag = instance.vnode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT;\r\n  if (shapeFlag) {\r\n    setupStateComponent(instance);\r\n  } else {\r\n    // 如果无状态，说明是简单组件，直接渲染即可。\r\n  }\r\n};\r\n\r\n// 将全局的组件实例暴露出去\r\nexport let currentInstance;\r\n\r\n\r\n// 处理有状态的组件\r\nfunction setupStateComponent(instance) {\r\n    // setup方法的返回值是我们的render函数的参数\r\n    // 拿到组件的setup方法\r\n    //   其中我们可以知道：\r\n    // 1、setup方法的参数是组件参数props、上下文对象context（包含了父组件传递下来的非 prop 属性attrs、可以用来触发父组件中绑定的事件函数emit、一个指向当前组件实例的引用root、用来获取插槽内容的函数slot等）\r\n    // 2、setup方法的返回值可以是一个对象（包含代理的响应式属性以供渲染函数使用），也可以是直接返回渲染函数\r\n    const Component = instance.type; // createVNode时传入给type的是rootComponent，本质是一个对象，组件的所有属性都在这里，比如setup方法，比如render方法\r\n    const { setup } = Component;\r\n    //处理参数\r\n    //const setupContext = createContext(instance); // 返回一个上下文对象\r\n    //setup(instance.props, setupContext); // 实际执行的setup函数（实参）\r\n\r\n    //instance.proxy = new Proxy(instance.ctx, componentPublicInstance as any);\r\n\r\n    if (setup) {\r\n        const setupContext = createContext(instance); // 返回一个上下文对象\r\n        //调用组件定义中的 setup 函数，传入 props 和上下文\r\n        const setupResult = setup(instance.props, setupContext); // 实际执行的setup函数（实参）\r\n        // setup返回值有两种情况：1、对象；2、函数==>根据不同情况进行处理\r\n        // 如果是对象，则将值放在instance.setupState；如果是函数，则就是render函数\r\n        handlerSetupResult(instance, setupResult); \r\n      } else {\r\n        // 没有setup则会有instance.type.render方法的（处理无setup有render的情况）\r\n        finishComponentSetup(instance); // 通过vnode拿到render方法\r\n      }\r\n      \r\n}\r\n\r\n\r\n// 处理context上下文对象（包含了父组件传递下来的非 prop 属性attrs、可以用来触发父组件中绑定的事件函数emit、一个指向当前组件实例的引用root、用来获取插槽内容的函数slot等）\r\nfunction createContext(instance) {\r\n  return {\r\n    sttrs: instance.attrs,\r\n    slots: instance.slots,\r\n    emit: () => {},\r\n    expose: () => {},\r\n  };\r\n}\r\n\r\n// 处理setup函数的返回结果\r\nfunction handlerSetupResult(instance, setupResult) {\r\n    if (isFunction(setupResult)) {\r\n      instance.render = setupResult; // 处理有setup且返回函数的情况==>没必要使用组件的render方法了\r\n    } else if (isObject(setupResult)) {\r\n        //setupState是vue组件实例instance中用于存储setup()返回对象中的状态的属性\r\n      instance.setupState = setupResult; // 处理有setup且返回对象的情况==>要使用组件的render方法了\r\n    }\r\n  \r\n    // 最终也会走render（把render挂载到实例上去）\r\n    finishComponentSetup(instance);\r\n  }\r\n\r\n// 处理render（把render挂载到实例上去）\r\nfunction finishComponentSetup(instance) {\r\n    // 判断组件中有没有render方法，没有则\r\n    const Component = instance.type; // createVNode时传入给type的是rootComponent，本质是一个对象，组件的所有属性都在这里，比如setup方法，比如render方法\r\n    if (!instance.render) {\r\n      // 这里的render指的是上面instance实例的render属性，在handlerSetupResult函数中会赋值（赋值的情况：组件有setup且返回函数），如果没有setup则此时会为false，则需要赋组件的render方法\r\n      //template 是 HTML 字符串。Vue 会用它的模板编译器（@vue/compiler-dom）把它编译成 JS 渲染函数。\r\n      if (!Component.render && Component.template) {\r\n        // TODO：模版编译\r\n      }\r\n      instance.render = Component.render;\r\n    }\r\n    //console.log(instance.render);\r\n  }\r\n  \r\n  \r\n\r\n  ","// weak-vue\\packages\\runtime-core\\src\\apilifecycle.ts\r\nimport { currentInstance, setCurrentInstance } from \"./component\";\r\n\r\n// 处理生命周期\r\nconst enum lifeCycle {\r\n  BEFOREMOUNT = \"bm\",\r\n  MOUNTED = \"m\",\r\n  BEFOREUPDATE = \"bu\",\r\n  UPDATED = \"u\",\r\n}\r\n\r\n// 常用的生命周期钩子——柯里化操作\r\nexport const onBeforeMount = createHook(lifeCycle.BEFOREMOUNT);\r\nexport const onMounted = createHook(lifeCycle.MOUNTED);\r\nexport const onBeforeUpdate = createHook(lifeCycle.BEFOREUPDATE);\r\nexport const onUpdated = createHook(lifeCycle.UPDATED);\r\n\r\n// 创建生命周期钩子\r\nfunction createHook(lifecycle: lifeCycle) {//这个函数 createHook 接收一个参数 lifecycle，这个参数必须是 lifeCycle 类型。\r\n  // 返回一个函数,这个函数接收两个参数，hook和target。hook是生命周期中的方法，target是当前组件实例\r\n  return function (hook, target = currentInstance) {\r\n    // 获取到当前组件的实例，然后和生命周期产生关联\r\n    injectHook(lifecycle, hook, target);\r\n  };\r\n}\r\n\r\n// 注入生命周期钩子\r\nfunction injectHook(lifecycle: lifeCycle, hook, target = currentInstance) {\r\n  console.log(\"当前组件实例：\", target);\r\n  // 注意：vue3.x中的生命周期都是在setup中使用的\r\n  if (!target) {\r\n    console.warn(`lifecycle: ${lifecycle} is used outside of setup`);\r\n    return;\r\n  }\r\n  // 给这个实例添加生命周期\r\n  //检查 target 上是否已经存在某个生命周期对应的钩子数组（例如 target['mounted']）,如果已经有了，就用它,没有，就新建一个空数组并赋值给 target[lifecycle]\r\n  const hooks = target[lifecycle] || (target[lifecycle] = []);\r\n\r\n  //hooks.push(hook);//添加当前这个生命周期\r\n\r\n\r\n  // 注意：vue3.x中获取组件示例是通过getCurrentInstance()方法获取的\r\n  //利用函数包装（劫持）技术，在生命周期钩子执行前自动设置当前组件实例，以便用户可以在钩子中通过getCurrentInstance（）拿到当前组件实例\r\n  // 为了可以在生命周期中获取到组件实例，vue3.x通过切片的手段实现（即函数劫持的思路，修改传入的hook，使得hook执行前设置当前组件实例到全局）\r\n  const rap = (hook) => {//rap是包装器的简写，用处是包裹用户传入的hook，注入实例上下文\r\n      setCurrentInstance(target);//设置当前组件实例为target(全局变量)\r\n      hook(); // 执行生命周期钩子前存放一下当前组件实例\r\n      setCurrentInstance(null);//执行完清除全局实例，避免污染\r\n    };\r\n    \r\n    hooks.push(rap);//跟上面相比，不是直接注册 hook，而是注册包装后的 rap，确保任何生命周期函数执行时，Vue 都能正确设置和清除 currentInstance。\r\n\r\n}\r\n\r\n// 生命周期的执行\r\nexport function invokeArrayFns(fns) {\r\n    fns.forEach((fn) => fn());\r\n  }\r\n","import { ShapeFlags } from \"@vue/shared\";\nimport { effect } from \"@vue/reactivity\";\nimport { apiCreateApp } from \"./apiCreateApp\";\nimport { createComponentInstance, setupComponet } from \"./component\";\nimport { CVnode, TEXT } from \"./vnode\";\nimport { invokeArrayFns } from \"./apilifecycle\";\n\n  // 实现渲染Vue3组件==>vnode==>render\nexport function createRender(renderOptionDom) {\n\n    // 创建一个effect让render函数执行(响应式)\n  const setupRenderEffect = (instance, container) => {\n    // 创建effect(原理可以回前面的内容找)\n    effect(function componentEffect() {\n      // 判断是否是初次渲染\n      if (!instance.isMounted) {//false表示组件是第一次渲染\n\n          // 渲染之前的阶段\n          let { bm, m } = instance;\n          if (bm) {\n            invokeArrayFns(bm);\n          }\n        // 获取到render返回值\n        const proxy = instance.proxy; // 已经代理了组件，可以访问到组件的所有属性和所有方法\n        // console.log(\"这是组件实例proxy：\");\n        // console.log(proxy);\n        const subTree = instance.render.call(proxy, proxy); // render函数执行，即调用render函数，第一个参数表示render函数的this指向组件实例proxy，第二个参数表示执行render函数的参数也是proxy\n        // console.log(\"h函数生成的vnode树：\", subTree);\n        patch(null, subTree, container); // 渲染vnode（此时是元素的vnode）\n        // 渲染完成的阶段\n        if (m) {\n          invokeArrayFns(m);\n        }\n        instance.isMounted = true;\n        \n      } else {//组件已经挂载了，不是第一次渲染\n        // TODO: 更新\n        let { bu, u } = instance;\n        if (bu) {\n          invokeArrayFns(bu);\n        }\n        // 对比新旧vnode--diff算法\n        let proxy = instance.proxy;//拿到组件实例的代理对象 proxy，它是通过 setupComponent 创建的，绑定了组件的属性、方法等\n        //拿到上一次渲染生成的虚拟 DOM（VNode），也就是“旧的 vnode 树”。之前在首次挂载的时候应该保存过一次const prevVnode = instance.subTree;\n        const prevVnode = instance.subTree; // 旧vnode，记得上面首次渲染在实例上挂载\n        const nextVnode = instance.render.call(proxy, proxy); // 新vnode，第一个 proxy 是 this，第二个 proxy 是参数（你实现 render 的时候需要用）。\n        instance.subTree = nextVnode;\n        patch(prevVnode, nextVnode, container); // 此时在patch方法中会对比新旧vnode，然后更新\n        if(u){\n          invokeArrayFns(u);\n        }\n      }\n    });\n  };\n\n\n\n  /** ---------------处理组件--------------- */\n  const processComponent = (n1, n2, container) => {//负责处理组件的渲染（初次渲染和更新两种情况）\n    if (n1 === null) {\n      // 组件第一次加载\n      mountComponent(n2, container);\n    } else {\n      // 更新\n    }\n  };\n\n  // 组件渲染的真正方法（实现由虚拟dom变成真实dom），步骤（核心）：\n  const mountComponent = (InitialVnode, container) => {\n    //InitialVnode是当前要挂载的虚拟节点\n    // 1、先有一个组件的实例对象（即Vue3组件渲染函数render传入的第一个参数proxy，其实proxy参数将组件定义的所有属性合并了，等效于在setup入口函数里面返回一个函数，可以用proxy.来获取属性）\n    const instanece = (InitialVnode.component =//InitialVnode.component是指当前组件虚拟节点所关联的组件实例对象\n      //createComponentInstance会基于当前虚拟节点 InitialVnode 创建一个组件实例对象（包含 props、setup 返回值、render 函数等）\n      createComponentInstance(InitialVnode)); // 记得在weak-vue\\packages\\runtime-core\\src\\vnode.ts文件给vnode定义中加上这个属性\n      //↑vnode.component 本来是 null，你需要手动创建一个组件实例对象并挂载回 vnode.component，\n    // 2、解析数据到这个实例对象中\n    setupComponet(instanece);\n    // 3、创建一个effect让render函数执行\n    setupRenderEffect(instanece,container);\n  };\n\n\n\n\n\n\n/** ---------------处理元素--------------- */\nconst processElement = (n1, n2, container) => {\n  if (n1 === null) {\n    // 元素第一次挂载\n    mountElement(n2, container);\n  } else {\n    // 更新\n    console.log(\"同一个元素更新！！！\");\n    patchElement(n1, n2, container);\n  }\n\n};\n\n// 元素的更新方法\nconst patchElement = (n1, n2, container) => {\n  const oldProps = n1.props || {};\n  const newProps = n2.props || {};\n  // 1、对比属性\n  //把 n1.el 赋值给 n2.el，同时赋值给局部变量 el 以供后续使用。\n  let el = (n2.el = n1.el); // 获取真实dom\n  patchProps(el, oldProps, newProps);\n  // 2、对比子节点--与初次挂载一样，需要将可能的字符串也要转换成vnode\n  //将 n1.children（旧的子节点数组）统一转换成虚拟节点（VNode）格式 \n  n1.children = n1.children.map((item) => {//原本的 children 数组中每一项 item 进行处理\n  //map:对数组中的每一个元素执行一次函数处理，并生成一个新的数组，不会改变原数组。\n    return CVnode(item);\n  });\n  n2.children = n2.children.map((item) => {\n    return CVnode(item);\n  });\n  patchChildren(n1, n2, el);\n};\n\n// 对比属性有三种情况：\n// 1、新旧属性都有，但是值不一样\n// 2、旧属性有，新属性没有\n// 3、新属性有，旧属性没有\nconst patchProps = (el, oldProps, newProps) => {\n  if (oldProps !== newProps) {\n    // 1、新旧属性都有，但是值不一样\n    for (const key in newProps) {\n      const prev = oldProps[key];\n      const next = newProps[key];\n      if (prev !== next) {\n        hostPatchProp(el, key, prev, next); // 替换属性\n      }\n    }\n    // 2、新属性有，旧属性没有\n    for (const key in oldProps) {\n      if (!(key in newProps)) {\n        hostPatchProp(el, key, oldProps[key], null); // 删除属性\n      }\n    }\n    // 3、旧属性有，新属性没有\n    for (const key in newProps) {\n      if (!(key in oldProps)) {\n        hostPatchProp(el, key, null, newProps[key]); // 新增属性\n      }\n    }\n  }\n};\n\n// 对比子节点有四种情况：\n// 1、旧的有子节点，新的没有子节点\n// 2、旧的没有子节点，新的有子节点\n// 3、旧的有子节点，新的也有子节点，但是是文本节点（最简单的情况）\n// 4、旧的有子节点，新的也有子节点，但是可能是数组\nconst patchChildren = (n1, n2, el) => {\n  const c1 = n1.children;\n  const c2 = n2.children;\n  const prevShapeFlag = n1.shapeFlag;\n  const newShapeFlag = n2.shapeFlag;\n  if (newShapeFlag & ShapeFlags.TEXT_CHILDREN) {\n    // 新的是文本节点，直接替换\n    if (c2 !== c1) {\n      hostSetElementText(el, c2);\n    }\n  } else {\n    // 新的是数组，此时要判断旧的\n    if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n      // 旧的也是数组（较复杂）\n      patchKeyChildren(c1, c2, el);\n    } else {\n      // 旧的是文本节点，将文本节点清空，然后再将新的节点进行渲染\n      hostSetElementText(el, \"\");\n      mountChildren(el, c2);\n    }\n  }\n};\n\n//i: 从前往后，第一个不同节点的索引。\n//e1: 从后往前，旧节点列表中最后一个非复用节点的索引。\n//e2: 从后往前，新节点列表中最后一个非复用节点的索引。\nconst patchKeyChildren = (c1, c2, el) => {\n  // 下面是vue3的diff算法，处理简单情况时也用到了双端diff：\n\n  let i = 0;\n  let e1 = c1.length - 1;\n  let e2 = c2.length - 1;\n  // 1、diff from start，即从头开始对比--简单情况1：旧的排列和新的排列前面节点一致，这些节点是可以复用的\n  while (i <= e1 && i <= e2) {\n    const n1 = c1[i];\n    const n2 = c2[i];\n    if (isSameVnode(n1, n2)) {\n      // 递归对比子节点，先渲染出来，相当于重新走一次流程\n      patch(n1, n2, el);\n    } else {\n      break;\n    }\n    i++;\n  }\n  // 2、diff from end，即从尾开始对比--简单情况2：旧的排列和新的排列后面节点一致，这些节点是可以复用的\n  while (i <= e1 && i <= e2) {\n    const n1 = c1[e1];\n    const n2 = c2[e2];\n    if (isSameVnode(n1, n2)) {\n      // 递归对比子节点，先渲染出来，相当于重新走一次流程\n      patch(n1, n2, el);\n    } else {\n      break;\n    }\n    e1--;\n    e2--;\n  }\n\n  // 1、新的子节点数量多的情况--要新增，又分为两种情况：1、新增的节点在旧的节点之前，2、新增的节点在旧的节点之后\n  if (i > e1) {//判断是否 旧节点全部处理完了，而新节点还有剩余的。\n    const nextPos = e2 + 1; // e2+1要么表示后面部分可复用的节点的倒数最后一个，要么为null（即后面部分没有可复用的节点）\n    //c2[nextPos].el 是 “新子节点列表中，位于 nextPos 位置的虚拟节点（VNode）所对应的真实 DOM 元素”。\n    //.el是vnode的一个属性，表示这个虚拟节点对应的真实dom元素\n    const anchor = nextPos < c2.length ? c2[nextPos].el : null;//如果 nextPos < c2.length，说明后面还有元素，我们就插入到它前面；否则说明是末尾插入，anchor 就是 null，表示插入到末尾。\n    while (i <= e2) {\n      console.log(\n        \"要插入的节点：\",\n        c2[i].key,\n        \"，插入到：\",\n        anchor || \"null\",\n        \"节点之前\"\n      );\n      patch(null, c2[i], el, anchor); // 记得给patch函数以及里面使用的相关方法传入anchor参数\n      i++;\n    }\n  }else if (i > e2) {\n    // 2、旧的子节点数量多的情况--要删除\n    while (i <= e1) {\n      console.log(\"要删除的节点：\", c1[i].key);\n      unmount(c1[i]);\n      i++;\n    }\n  }else{\n    // 3、乱序，并不是简单将中间乱序节点全部删除再全部新增，而是要尽可能的复用节点\n    // 解决思路：（1）以新的乱序个数创建一个映射表；（2）再用旧的乱序的数据去映射表中查找，如果有，说明是可以复用的，如果没有，说明是该旧节点需要删除的\n    const s1 = i; // 旧的乱序开始位置\n    const s2 = i; // 新的乱序开始位置\n    // 创建表\n    let keyToNewIndexMap = new Map();\n    // 解决两个问题：1、复用的节点渲染位置不对；2、要新增的节点没有插入。\n    const toBePatched = e2 - s2 + 1; // 新的乱序的数量\n    //这个数组，每个位置代表：“新 vnode 中的一个乱序子节点”，目的是记录这个位置的 vnode 是否在旧 vnode 中找到匹配的 key\n    const newIndexToOldIndexMap = new Array(toBePatched).fill(0); // 新的乱序的数量的数组，每个元素都是0\n\n\n    // 用新的乱序数据去创建映射表\n    for (let i = s2; i <= e2; i++) {\n      const nextChild = c2[i];\n      keyToNewIndexMap.set(nextChild.key, i);//「新子节点的 key -> 新索引位置」 比如'E'=>2\n    }\n    //console.log(\"映射表：\", keyToNewIndexMap);\n\n    // 新：A B C D E F G==>乱序映射表：D=>3，E=>4，F=>5。\n    // 旧：A B C M F E Q G==>乱序映射表：M=>3，F=>4，E=>5，Q=>6。\n    // 去旧的乱序数据中查找\n    for (let i = s1; i <= e1; i++) {\n      const oldChildVnode = c1[i];\n      const newIndex = keyToNewIndexMap.get(oldChildVnode.key);\n      if (!newIndex) {\n        // 说明旧的节点需要删除（即M和Q）\n        console.log(\"要删除的节点：\", oldChildVnode.key);\n        unmount(oldChildVnode);\n      } else {\n        console.log(\"要复用的节点：\", oldChildVnode.key);\n        //我们找到了一个“可以复用的旧 vnode”，就把它在旧 children 中的位置（i）记录下来：\n        //i 是旧节点的下标，说明我们当前处理的是旧的第几个 vnode\n        newIndexToOldIndexMap[newIndex - s2] = i + 1; // 现在将复用的节点的位置改为旧的乱序的位置+1（为了区分是否被使用过）\n        patch(oldChildVnode, c2[newIndex], el);\n      }\n    }\n    // 获取最长递增子序列的索引\n    console.log(\"乱序节点的索引数组newIndexToOldIndexMap:\", newIndexToOldIndexMap);\n    //increasingNewIndexSequence不是记录完整路径，只是告诉你“哪些节点位置是对的，不需要动”。存的不是值 是索引下标\n    const increasingNewIndexSequence = getSequence(newIndexToOldIndexMap);\n    console.log(\n      \"newIndexToOldIndexMap数组中最长递增子序列数组increasingNewIndexSequence:\",\n      increasingNewIndexSequence\n    );\n    let j = increasingNewIndexSequence.length - 1;\n\n\n    // 此时根据这个位置数组去移动或者新增我们的节点(从后往前处理)\n    for (let i = toBePatched - 1; i >= 0; i--) {\n      const currentIndex = s2 + i; // 当前要处理的新的乱序的节点的位置\n      const anchor = currentIndex + 1 < c2.length ? c2[currentIndex + 1].el : null;\n      if (newIndexToOldIndexMap[i] === 0) {\n        // 说明是新增的节点\n        console.log(\n          \"新增的节点：\",\n          c2[currentIndex].key,\n          \"，插入到：\",\n          anchor || \"null\",\n          \"节点之前\"\n        );\n        patch(null, c2[currentIndex], el, anchor); // 比如从后往前遍历到D时，插入到E的前面。\n      } else {\n        // 说明是要移动的可复用节点\n        console.log(\n          \"要移动的节点：\",\n          c2[currentIndex].key,\n          \"，移动到：\",\n          anchor || \"null\",\n          \"节点之前\"\n        );\n        // 这个插入需要一个个的插入，大量情况下会可能导致性能问题。\n      // 用最长递增子序列去优化，如果在区间内，就不用移动，如果不在区间内，就移动。\n      //increasingNewIndexSequence是\tnewIndexToOldIndexMap 上的 最长递增子序列的下标列表\n      if (i !== increasingNewIndexSequence[j]) {\n        hostInsert(c2[currentIndex].el, el, anchor); // 比如从后往前遍历到F时，应该移动到G的前面；从后往前遍历到E时，应该移动到F的前面。此时已渲染序列为A B C E F G\n      } else {\n        j--;\n      }\n      }\n    }\n\n\n  }\n};\n\n\n\n\n\n\nconst mountElement = (vnode, container) => {\n  // 递归渲染子节点==>dom操作==》挂载到container/页面上\n  const { shapeFlag, props, type, children } = vnode;\n  // 1、创建元素--记得把真实dom挂载到vnode上，方便后面更新时使用\n  let el = (vnode.el = hostCreateElement(type));//这是简写写法，相当于vnode.el = hostCreateElement(type); // 1. 创建真实 DOM 元素并挂载到 vnode.el 上；let el = vnode.el;                  // 2. 将 vnode.el 赋值给局部变量 el\n  // 2、创建元素的属性\n  if (props) {\n    for (const key in props) {\n      hostPatchProp(el, key, null, props[key]);\n    }\n  }\n  //处理children\n  if (children) {\n    if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\n      console.log(\"这是文本字符串形式子节点：\", children);\n      hostSetElementText(el, children); // 文本形式子节点，比如这种情况：h('div',{},'张三')，将children直接插入到el中\n    } else if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n      // 递归渲染子节点\n      console.log(\"这是数组形式子节点：\", children);\n      mountChildren(el, children); // 数组形式子节点，比如这种情况：h('div',{},['张三',h('p',{},'李四')])，将children递归渲染插入到el中\n    }\n  }\n  // 3、放入到对应的容器中\n  hostInsert(el, container);\n};\n\n// 递归渲染子节点\nconst mountChildren = (container, children) => {\n  for (let i = 0; i < children.length; i++) {\n    // children[i]两种情况：1、['张三']这种元素，字符串的形式；2、h('div',{},'张三')这种元素，对象的形式（vnode）\n    // 但两种情况都需要转换成vnode来处理，方便借助patch函数来渲染\n    const child = (children[i] = CVnode(children[i])); // 第一种情况转换成vnode，记得将children[i]重新赋值\n    // 递归渲染子节点（vnode包含了元素、组件、文本三种情况）\n    patch(null, child, container);\n  }\n};\n\n\n/** ---------------处理文本--------------- */\nconst processText = (n1, n2, container) => {//n1是旧的vnode(null表示首次渲染)，n2表示新的vnode,即为当前的文本节点\n  if (n1 === null) {\n    // 创建文本==>直接渲染到页面中（变成真实dom==>插入）\n    //hostCreateText(n2.children):调用平台相关的 createTextNode，生成真实文本节点。\n    //n2.el = ...:将创建的 DOM 文本节点挂到 vnode 上，便于后续更新。\n    //hostInsert(..., container):将文本插入容器中\n    hostInsert((n2.el = hostCreateText(n2.children)), container);\n  } else {\n    // 如果前后不一致，更新文本\n    if (n2.children !== n1.children) {\n      const el = (n2.el = n1.el!); // el是上面初次创建的真实文本节点\n      hostSetText(el, n2.children as string);\n    }\n  }\n};\n\n\n  /**---------------------------------------------------------- */\n  // 判断是否是同一个元素\n  const isSameVnode = (n1, n2) => {\n    return n1.type === n2.type && n1.key === n2.key;\n  };\n  // 卸载老的元素\n  const unmount = (vnode) => {\n    hostRemove(vnode.el);\n  };\n\n  // patch函数负责根据vnode的不同情况（组件、元素、文本）来实现对应的渲染\n  const patch = (n1, n2, container, anchor = null) => {\n    // 针对不同的类型采取不同的渲染方式（vnode有一个shapeFlag标识来标识组件/元素）\n    // diff算法\n    // 1、判断是不是同一个元素\n    if (n1 && n2 && !isSameVnode(n1, n2)) {\n      // 卸载老的元素\n      unmount(n1);\n      n1 = null; // n1置空，可以重新走组件挂载了，即传给processElement的n1为null，走mountElement方法\n    }\n    // 2、如果是同一个元素，对比props、children，此时传给processElement的n1为老的vnode，走patchElement方法\n\n    // 针对不同的类型采取不同的渲染方式（vonode有一个shapeFlag标识来标识组件/元素）\n    const { shapeFlag, type } = n2;\n    switch (type) {\n      case TEXT:\n        // 处理文本\n        processText(n1, n2, container);\n        break;\n      default:\n        // 等效于shapeFlag && shapeFlag === ShapeFlags.ELEMENT\n        //因为一个vnode可以有多个类型，比如是元素，又有子元素，不能只用===判断唯一性，要用位运算表示多个特征\n        //按位与:两个数的对应位都为 1，结果才是 1，否则就是 0\n        if (shapeFlag & ShapeFlags.ELEMENT) {//判断 shapeFlag 是否包含 ShapeFlags.ELEMENT 这个标志。它返回一个数字，若结果不为 0，则说明包含。\n          // 处理元素(h函数)\n          // console.log(\"此时处理的是元素！！！\");\n          processElement(n1, n2, container, anchor);\n        } else if (shapeFlag & ShapeFlags.STATEFUL_COMPONENT) {\n          // 处理组件\n          // console.log(\"此时处理的是组件！！！\");\n          processComponent(n1, n2, container);\n        }\n    }\n  };\n\n  // 真正实现渲染的函数（渲染vnode)\n  const render = (vnode, container) => {\n    // 第一次渲染（三个参数：旧的节点、当前节点、位置）\n    patch(null, vnode, container);\n  };\n\n\n\n\n  // 返回一个具有createApp方法的对象，其中createApp负责生成一个具有mount挂载方法的app对象（包含属性、方法等），进而实现1、生成vnode；2、render渲染vnode\n  return {\n    createApp: apiCreateApp(render),\n  };\n\n}\n\n\n\n\n","import { extend } from \"../../shared/src\";\n// runtime-dom是用于操作dom（节点、属性）的模块\n// 创建两个文件，分别用于处理节点nodeOps.ts与属性patchProp.ts\nimport { nodeOps } from \"./nodeOps\";\nimport { patchProps } from \"./patchProp\";\nimport { createRender } from \"../../runtime-core/src\";\n\n//nodeOps 是一组与 DOM 相关的操作方法，通常包含多个方法,patchProps 只是一个单一的函数，用于处理 DOM 属性的更新\n\n//nodeOps 是一个对象，包含多个与 DOM 节点相关的操作方法，因此需要作为对象传递。\n//patchProps 是一个函数，专门用于处理 DOM 属性更新，因此它直接作为一个函数传递。\n\n//这里有简写，等价于{ patchProps: patchProps }\n//{ patchProps }：这是一个对象，它的键是 patchProps，值是 patchProps 函数。花括号的作用是创建一个包含 patchProps 属性的对象。\n//const VueRuntimeDom = extend({ patchProps }, nodeOps);\n\n// Vue3的全部dom操作\nconst renderOptionDom = extend({ patchProps }, nodeOps);\n\n//rootComponent根组件，用户传入的Vue组件，rootProps根组件的props\nexport const createApp = (rootComponent, rootProps) => {\n  // 创建一个渲染的容器\n  let app = createRender(renderOptionDom).createApp(rootComponent, rootProps); // createRender返回的是一个具有createApp属性方法的对象，打点执行该createApp方法后返回一个app对象，里面有一个mount属性方法\n  let { mount } = app;//解构赋值，意思是从 app 对象中取出原始的 mount 方法，赋值给一个变量 mount。\n  //重写mount方法,但是前面保存的变量 mount 仍然保留对原始函数的引用！\n  //参数 container 是选择器或 DOM 元素，表示挂载的目标容器。\n  app.mount = function (container) {\n    // 挂载组件之前要清空原来的内容\n    container = nodeOps.querySelector(container);//获取实际的DOM元素\n    container.innerHTML = \"\";//清空\n    // 渲染新的内容(挂载dom)\n    mount(container);\n  };\n  return app;\n}\n\nexport * from \"@vue/runtime-core\";\n\n"],"names":["isString","isObject","isArray","hasOwn","isFunction","effect"],"mappings":"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"}
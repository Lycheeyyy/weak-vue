{"version":3,"file":"compiler-core.esm-bundler.js","sources":["../src/ast.ts","../src/parse.ts","../src/transform.ts","../src/utils.ts","../src/transforms/transformElement.ts","../src/transforms/transformText.ts","../src/transforms/vOn.ts","../src/transforms/vBind.ts","../src/codegen.ts","../src/compile.ts"],"sourcesContent":["import { isString } from \"@vue/shared\";\r\n// AST节点类型\r\nexport const enum NodeTypes {\r\n  // AST节点类型\r\n  ROOT, // 表示根节点\r\n  ELEMENT, // 表示元素节点，可能是div、span等原生标签，也可能是自定义组件\r\n  TEXT, // 表示文本节点\r\n  SIMPLE_EXPRESSION, // 表示简单表达式节点\r\n  ATTRIBUTE, // 表示属性节点\r\n  DIRECTIVE, // 表示指令节点\r\n  INTERPOLATION, // 表示插值节点\r\n\r\n  // 表示可以包含子节点的结构，比如元素节点、文本节点等\r\n  TEXT_CALL, // 表示文本节点中的插值节点，比如parse {{ element }}</div>中的{{ element }}\r\n  COMPOUND_EXPRESSION, // 表示复合表达式节点，比如{{ a + b }}中的a + b\r\n\r\n  // For codegen，用于代码生成\r\n  VNODE_CALL, // 表示创建VNode节点的代码\r\n  JS_PROPERTY, // 表示JS对象的属性\r\n  JS_CALL_EXPRESSION, // 表示JS的调用表达式\r\n  JS_ARRAY_EXPRESSION, // 表示JS的数组表达式\r\n  JS_OBJECT_EXPRESSION, // 表示JS的对象表达式\r\n}\r\n  \r\n// 标签类型\r\n//看标签时原生标签还是自定义组件——vue源码采用穷举加映射的思路\r\nexport const enum ElementTypes {\r\n    ELEMENT,\r\n    COMPONENT,\r\n  }\r\n\r\n// 创建AST的根节点\r\nexport const createRoot = (children) => {\r\n    return {\r\n      type: NodeTypes.ROOT,\r\n      children,\r\n    };\r\n  };\r\n\r\n\r\n/**\r\n * 下面是与创建codegenNode相关的工具函数\r\n */\r\n// 创建一个简单的表达式节点\r\nexport const createSimpleExpression = (content, isStatic = false) => {\r\n    return {\r\n      type: NodeTypes.SIMPLE_EXPRESSION,\r\n      content,\r\n      isStatic,\r\n    };\r\n};\r\n  // 创建一个对象属性节点\r\nexport const createObjectProperty = (key, value) => {\r\n    return {\r\n      type: NodeTypes.JS_PROPERTY,\r\n      key: isString(key) ? createSimpleExpression(key, true) : key,\r\n      value,\r\n    };\r\n};\r\n  // 创建一个函数调用表达式节点\r\nexport const createCallExpression = (args = []) => {\r\n    return {\r\n      type: NodeTypes.JS_CALL_EXPRESSION,\r\n      arguments: args,\r\n    };\r\n};\r\n  // 创建一个对象表达式节点\r\nexport const createObjectExpression = (properties) => {\r\n    return {\r\n      type: NodeTypes.JS_OBJECT_EXPRESSION,\r\n      properties,\r\n    };\r\n};\r\n  // 这个函数是用来生成 codegenNode 的\r\nexport const createVNodeCall = (\r\n    type,\r\n    tag,\r\n    props,\r\n    children,\r\n    patchFlag,\r\n    dynamicProps,\r\n    directives,\r\n    isComponent\r\n  ) => {\r\n    // 源码这里还会处理 helper，这里为了方便暂不处理\r\n    return {\r\n      // 源码这里是 type：NodeTypes.VNODE_CALL，这里为了方便后面处理直接赋值为原本的节点类型\r\n      type,\r\n      tag,\r\n      props,\r\n      children,\r\n      patchFlag,\r\n      dynamicProps,\r\n      directives,\r\n      isComponent,\r\n    };\r\n};\r\n  \r\n","import { isHTMLTag, isVoidTag } from \"@vue/shared\";\r\nimport { createRoot, ElementTypes, NodeTypes } from \"./ast\";\r\n\r\n// 创建parse解析上下文\r\nexport const createParserContext = (content) => { \r\n  return {\r\n    source: content, // 模板字符串\r\n    // 源码中还有很多\r\n    // 比如\r\n    // options,\r\n    // column: 1,\r\n    // line: 1,\r\n    // offset: 0,\r\n    // 但这里只用到了 source\r\n  };\r\n};\r\n\r\n// 生成完整的AST\r\nexport const baseParse = (content) => { //const content = \"<div><p>Hello</p></div>\";\r\n  const context = createParserContext(content);\r\n  // 具体的解析逻辑\r\n  const children = parseChildren(context); //真正开始递归解析 HTML 模板，返回所有子节点的数组 children。\r\n  return createRoot(children);//最终返回一个根节点包裹子节点，形成完整的AST结构\r\n};\r\n\r\n// 解析模板字符串\r\nconst parseChildren = (context) => {\r\n    // 具体的解析逻辑，需要调用多个工具函数根据实际情况解析\r\n    // 模版是一个长长的存在嵌套的字符串，我们需要递归的解析\r\n    const nodes = [];\r\n    while (!isEnd(context)) {\r\n      const s = context.source;\r\n  \r\n      let node;\r\n  \r\n      // 此处做了简化\r\n      // 源码这里有一大串的 if else if else\r\n      // 但是很多都是处理比如\r\n      // '<!--' '<!DOCTYPE' '<![CDATA['\r\n      // 还有很多容错处理\r\n  \r\n      // 以 < 开头则是元素\r\n      if (s[0] === \"<\") {\r\n        node = parseElement(context);\r\n      }\r\n      // 以 {{ 开头则是插值表达式\r\n      else if (startsWith(s, \"{{\")) {\r\n        node = parseInterpolation(context);\r\n      }\r\n      // 否则就是文本节点\r\n      else {\r\n        node = parseText(context);\r\n      }\r\n  \r\n      // 源码中写了个 pushNode 方法来控制，这里直接写出来了\r\n      nodes.push(node);\r\n    }\r\n  \r\n    return nodes;\r\n  };\r\n  \r\n\r\n// 解析元素节点\r\nconst parseElement = (context) => {\r\n    // 返回一个对象结构表示解析出来的元素节点\r\n    const element = parseTag(context);\r\n  \r\n    // 如果是自闭合标签就不用解析子节点和闭合标签了\r\n    // 但是 <br /> 合法，<br> 也是合法的\r\n    // 因此用 isVoidTag 判断一下\r\n    if (element.isSelfClosing || isVoidTag(element.tag)) {\r\n      return element;\r\n    }\r\n  \r\n    element.children = parseChildren(context);\r\n  \r\n    // 里面要负责一个功能：只是要分割掉闭合标签 </div>，因此不用接收\r\n    parseTag(context);\r\n  \r\n    return element;\r\n  };\r\n\r\n// 解析标签内容\r\n// 进来时长这样\r\n// <div class=\"a\" v-bind:b=\"c\">parse {{ element }}</div>\r\nconst parseTag = (context) => {\r\n    //其中 /?\t表示匹配 0 个或 1 个 /，用于区分起始标签和结束标签（如 <div> vs </div>）\r\n    //</?：匹配斜杠和标签名前面的可选斜杠（表示闭合标签）\r\n    //[a-z]\t标签名第一个字符必须是英文字母      [^\\t\\r\\n\\f />]*\t后面可以跟任意多个不是 空白字符、/ 或 > 的字符（即标签名的其它部分）\r\n    //i表示忽略大小写\r\n    const tagReg = /^<\\/?([a-z][^\\t\\r\\n\\f />]*)/i;\r\n\r\n    // tagReg.exec() 方法会返回一个数组作为匹配结果，其中第一个元素是整个匹配到的字符串，而后面的元素则是每个捕获组（如果有的话）匹配到的内容。\r\n    // 这时的 match 是 ['<div', 'div']\r\n    //match[0] 是 <div，而 match[1] 是 div——————>match[0] 总是完整匹配的那一段,match[1] 是括号 () 内捕获的那一段，也就是你想要的标签名。\r\n    const match = tagReg.exec(context.source);\r\n    const tag = match[1];\r\n\r\n    advanceBy(context, match[0].length);\r\n    advanceSpaces(context);\r\n\r\n    // 此时 context.source\r\n    // class=\"a\" v-bind:b=\"c\">parse {{ element }}</div>\r\n\r\n    // parseAttributes 下面再实现\r\n    const { props, directives } = parseAttributes(context);\r\n\r\n    // 此时 context.source 会变成\r\n    // >parse {{ element }}</div>\r\n\r\n    const isSelfClosing = startsWith(context.source, \"/>\");\r\n\r\n    // 分割掉 \"/>\" 或 \">\"\r\n    advanceBy(context, isSelfClosing ? 2 : 1);\r\n\r\n    // 判断是组件还是原生元素\r\n    const tagType = isHTMLTag(tag)\r\n      ? ElementTypes.ELEMENT\r\n      : ElementTypes.COMPONENT;\r\n  \r\n    return {\r\n      type: NodeTypes.ELEMENT,\r\n      tag,\r\n      tagType,\r\n      props,\r\n      directives,\r\n      isSelfClosing,\r\n      children: [],\r\n    };\r\n};\r\n\r\n// 解析所有属性\r\n// 进来时长这样\r\n// class=\"a\" v-bind:b=\"c\">parse {{ element }}</div>\r\nconst parseAttributes = (context) => {\r\n    const props = [];\r\n    const directives = [];\r\n  \r\n    // 循环解析\r\n    // 遇到 \">\" 或者 \"/>\" 或者 context.source 为空字符串了才停止解析\r\n    while (\r\n      context.source.length > 0 &&\r\n      !startsWith(context.source, \">\") &&\r\n      !startsWith(context.source, \"/>\")\r\n    ) {\r\n      // 调用前\r\n      // class=\"a\" v-bind:b=\"c\">parse {{ element }}</div>\r\n      // parseAttributes 下面再实现\r\n      const attr = parseAttribute(context);\r\n      // 调用后\r\n      // v-bind:b=\"c\">parse {{ element }}</div>\r\n  \r\n      if (attr.type === NodeTypes.DIRECTIVE) {\r\n        directives.push(attr);\r\n      } else {\r\n        props.push(attr);\r\n      }\r\n    }\r\n  \r\n    return { props, directives };\r\n};\r\n\r\n// 解析单个属性\r\n// 进来时长这样\r\n// class=\"a\" v-bind:b=\"c\">parse {{ element }}</div>\r\nconst parseAttribute = (context) => {\r\n    // 匹配属性名的正则\r\n    //^（在方括号里）表示“不匹配以下字符”。\r\n    const namesReg = /^[^\\t\\r\\n\\f />][^\\t\\r\\n\\f />=]*/;\r\n  \r\n    // match 这时是 [\"class\"]\r\n    const match = namesReg.exec(context.source);\r\n    const name = match[0];\r\n  \r\n    // 分割掉属性名和前面的空格\r\n    advanceBy(context, name.length);\r\n    advanceSpaces(context);\r\n    // context.source 这时是\r\n    // =\"a\" v-bind:b=\"c\">parse {{ element }}</div>\r\n  \r\n    let value;\r\n    if (startsWith(context.source, \"=\")) {\r\n      // 分割掉 \"=\"\r\n      advanceBy(context, 1);\r\n      advanceSpaces(context);\r\n  \r\n      // parseAttributeValue 负责解析属性值，后面再实现\r\n      // 调用前\r\n      // \"a\" v-bind:b=\"c\">parse {{ element }}</div>\r\n      value = parseAttributeValue(context);\r\n      advanceSpaces(context);\r\n      // 调用后\r\n      // v-bind:b=\"c\">parse {{ element }}</div>\r\n    }\r\n  \r\n    // 上面获取了属性名 name 和属性值 value\r\n    // TODO--解析指令\r\n    if (/^(:|@|v-[A-Za-z0-9-])/.test(name)) {//判断这个 name 是不是 Vue 的指令，比如 :xx / @xx / v-xxx\r\n      let dirName, argContent;\r\n  \r\n    // 类似 <div :a=\"b\" />\r\n    if (startsWith(name, \":\")) {\r\n      dirName = \"bind\";\r\n      argContent = name.slice(1);//去掉冒号，拿到属性名 比如'a'\r\n    }\r\n  \r\n    // 类似 <div @click=\"a\" />\r\n    else if (startsWith(name, \"@\")) {\r\n      dirName = \"on\";\r\n      argContent = name.slice(1);\r\n    }\r\n  \r\n    // 类似 <div v-bind:a=\"b\" />\r\n    else if (startsWith(name, \"v-\")) {\r\n      [dirName, argContent] = name.slice(2).split(\":\");\r\n    }\r\n  \r\n    // 返回指令节点\r\n    return {\r\n      type: NodeTypes.DIRECTIVE,\r\n      name: dirName,\r\n      exp: value && {\r\n        type: NodeTypes.SIMPLE_EXPRESSION,\r\n        content: value,\r\n        isStatic: false,\r\n      },\r\n      arg: argContent && {\r\n        type: NodeTypes.SIMPLE_EXPRESSION,\r\n        content: argContent,\r\n        isStatic: true,\r\n      },\r\n    };\r\n  }\r\n\r\n};\r\n\r\n  // 获取属性值\r\n// 进来时是这样的\r\n// \"a\" v-bind:b=\"c\">parse {{ element }}</div>\r\nconst parseAttributeValue = (context) => {\r\n    // 获取引号的第一部分\r\n    const quote = context.source[0];\r\n  \r\n    // 分割掉引号的第一部分\r\n    // a\" v-bind:b=\"c\">parse {{ element }}</div>\r\n    advanceBy(context, 1);\r\n  \r\n    // 找到匹配的结尾引号\r\n    const endIndex = context.source.indexOf(quote);//.indexOf(...) 是 JavaScript 中字符串的一个 方法，用于查找某个字符或字符串在另一个字符串中第一次出现的位置（索引）。\r\n  \r\n    // 获取属性值\r\n    const content = parseTextData(context, endIndex);//会取出 context.source.slice(0, endIndex)，也就是 \"a\" 里的 a。\r\n  \r\n    // 分割掉结尾引号前面的部分\r\n    advanceBy(context, 1);\r\n  \r\n    return content;//最终返回属性值（不带引号的），如 \"a\" → a\r\n  };\r\n  \r\n  \r\n                                                                       \r\n  /**\r\n * ----------------解析文本节点parseInterpolation----------------\r\n */\r\n// 解析插值表达式\r\n// 进来时是这样的\r\n// {{ element }}</div>\r\nconst parseInterpolation = (context) => {\r\n    const [open, close] = [\"{{\", \"}}\"];\r\n  \r\n    advanceBy(context, open.length);\r\n    // 这时变成\r\n    //  element }}</div>\r\n  \r\n    // 找 \"}}\" 的索引\r\n    const closeIndex = context.source.indexOf(close, open.length);\r\n  \r\n    const content = parseTextData(context, closeIndex).trim();//trim() 是 JavaScript 字符串的方法，用来 删除字符串两端的空白字符（不包括中间的）\r\n    advanceBy(context, close.length);\r\n    // 这时变成\r\n    // </div>\r\n  \r\n    return {\r\n      type: NodeTypes.INTERPOLATION,\r\n      content: {\r\n        type: NodeTypes.SIMPLE_EXPRESSION,\r\n        isStatic: false,\r\n        content,\r\n      },\r\n    };\r\n  };\r\n  \r\n\r\n/**\r\n * ----------------解析文本节点parseText----------------\r\n */\r\n// 解析文本节点\r\n// 进来时是这样的\r\n// parse {{ element }}</div>\r\nconst parseText = (context) => {\r\n    // 两个结束标识\r\n    const endTokens = [\"<\", \"{{\"];\r\n    let endIndex = context.source.length;\r\n  \r\n    for (let i = 0; i < endTokens.length; i++) {\r\n      // 找结束标识\r\n      const index = context.source.indexOf(endTokens[i]);\r\n  \r\n      // 找最靠前的一个结束标识\r\n      if (index !== -1 && index < endIndex) {\r\n        endIndex = index;\r\n      }\r\n    }\r\n  \r\n    // 把结束标识前的所有内容分割出来\r\n    const content = parseTextData(context, endIndex);\r\n  \r\n    return {\r\n      type: NodeTypes.TEXT,\r\n      content,\r\n    };\r\n  };\r\n  \r\n\r\n\r\n/**\r\n * ----------------解析模板字符串用到的一些工具函数----------------\r\n */\r\n// 分割字符串\r\nconst advanceBy = (context, numberOfCharacters) => { //把已经解析完的字符串从source中切掉\r\n  const { source } = context;\r\n  context.source = source.slice(numberOfCharacters);\r\n};\r\n// 删除空格\r\nconst advanceSpaces = (context) => {\r\n  const spacesReg = /^[\\t\\r\\n\\f ]+/;\r\n  const match = spacesReg.exec(context.source);//exec()用于在一个字符串中执行匹配操作，如果匹配成功，它返回一个 数组，数组的第一个元素是匹配到的文本。如果匹配失败，返回null\r\n  if (match) {\r\n    advanceBy(context, match[0].length);\r\n  }\r\n};\r\n// 判断字符串是否以 xxx 开头\r\nconst startsWith = (source, searchString) => {\r\n  return source.startsWith(searchString);\r\n};\r\n// 判断字符串是否解析结束（为空或者是否以 </ 开头）\r\nconst isEnd = (context) => {\r\n  const s = context.source;\r\n  return !s || startsWith(s, \"</\");//source是空字符串？或者source 是以 </ 开头的？（说明遇到了闭合标签）\r\n};\r\n// 分割文本数据\r\nconst parseTextData = (context, length) => {\r\n  const rawText = context.source.slice(0, length);//slice(0, 9) 表示从索引 0 到 9（不包含 9）截取字符串。\r\n  advanceBy(context, length);\r\n  return rawText;\r\n};\r\n  \r\n\r\n","import { NodeTypes } from \"./ast\";\r\nimport { isArray, isString } from \"@vue/shared\";\r\n\r\n// 创建处理节点的上下文\r\n// 当对AST做各种处理的时候，需要一个上下文来：记录当前遍历到哪一个节点、保存各种转换规则、保存根节点引用、管理状态\r\nexport function createTransformContext( // 这个函数是用来“准备变换工作的环境的”\r\n    root,//根节点\r\n    //nodeTransforms：节点转换函数数组（处理 AST 中所有类型的节点）。里面放的是方法\r\n    //directiveTransforms：指令转换器对象（处理 v-if、v-model 等）。\r\n    { nodeTransforms = [], directiveTransforms = {} } \r\n  ) {\r\n    const context = {\r\n      // plugin\r\n      nodeTransforms,\r\n      directiveTransforms,\r\n  \r\n      // state\r\n      root,\r\n      parent: null,\r\n      currentNode: root,\r\n    };\r\n    return context;\r\n  }\r\n  \r\n\r\n// 转换节点\r\nexport function transform(root, options) {\r\n    const context = createTransformContext(root, options);\r\n    traverseNode(root, context);//遍历处理每个节点，这里的处理也就是上文提到过的转换插件transform plugins\r\n    createRootCodegen(root);//生成根节点的codegenNode\r\n}\r\n\r\n// 遍历并转换节点\r\nexport function traverseNode(node, context) {\r\n    context.currentNode = node;\r\n    // 获取转换插件序列\r\n    const { nodeTransforms } = context;\r\n    const exitFns = [];//初始化退出函数数组\r\n    // 通过插件依次对当前节点进行处理\r\n    for (let i = 0; i < nodeTransforms.length; i++) {\r\n      // 获取退出函数并缓存\r\n      const onExit = nodeTransforms[i](node, context);\r\n      if (onExit) {\r\n        if (isArray(onExit)) {\r\n          exitFns.push(...onExit);\r\n        } else {\r\n          exitFns.push(onExit);\r\n        }\r\n      }\r\n      if (!context.currentNode) {//检查当前节点是否被删除，有些 transform 可能“删除”当前节点（比如过滤注释节点），这时就不继续递归了。\r\n        return;\r\n      } else {\r\n        node = context.currentNode;\r\n      }\r\n    }\r\n    // 根据节点类型递归遍历子节点\r\n    switch (node.type) { //如果节点是一个容器节点（如元素、根节点），递归处理它的子节点。\r\n      case NodeTypes.ELEMENT:\r\n      case NodeTypes.ROOT:\r\n        traverseChildren(node, context);\r\n        break;\r\n  \r\n      case NodeTypes.INTERPOLATION:\r\n      case NodeTypes.TEXT:\r\n        // TODO：处理插值节点和文本节点\r\n        break;\r\n    }\r\n  \r\n    context.currentNode = node;//再次设置 currentNode（以防被 transform 修改）\r\n  \r\n    // 倒序执行退出函数，从子树回到当前节点\r\n    // 从叶子节点往根节点执行\r\n    let i = exitFns.length;\r\n    while (i--) {\r\n      exitFns[i]();\r\n    }\r\n    //所以的退出函数会在子节点处理完成之后倒序执行，实现后序处理逻辑\r\n  }\r\n  \r\n  \r\n// 遍历子节点\r\nexport function traverseChildren(parent, context) {\r\n    for (let i = 0; i < parent.children.length; i++) {\r\n      const child = parent.children[i];\r\n    // 如果子节点是字符串就直接跳过，因为在 AST 的语义中，字符串不是合法的子节点类型，它们只是临时的中间数据，编译器不会对它们做 transform 处理。\r\n      if (isString(child)) continue;\r\n      // 函数开头中 traverseChildren(parent, context)的parent是函数内部的一个局部变量，其他函数比如后面的traverseNode是访问不到这个parent的\r\n      context.parent = parent; // 在遍历子节点前，把当前正在遍历的“父节点”记录在上下文中，方便后续的转换逻辑（比如插值、表达式、标签等）知道自己的“父亲是谁”。\r\n      traverseNode(child, context);\r\n    }\r\n}\r\n  \r\n\r\n// 生成根节点的 codegenNode\r\nexport function createRootCodegen(root) {\r\n    const { children } = root;\r\n    if (children.length === 1) {\r\n      const child = children[0];\r\n      if (child.type === NodeTypes.ELEMENT && child.codegenNode) { //如果 child 是元素节点，并且它自己已经有 codegenNode\r\n        const codegenNode = child.codegenNode;// 说明这个元素节点已经转换完毕，可以直接拿来当作渲染起点：\r\n  \r\n        root.codegenNode = codegenNode;\r\n      } else {\r\n        root.codegenNode = child;\r\n      }\r\n    }\r\n  \r\n    // 源码中实现了多根节点的支持\r\n    // else if (children.length > 1) {}\r\n  }\r\n  ","/**\r\n * 编译模块用到的一些工具函数\r\n */\r\n\r\nimport { NodeTypes } from \"./ast\";\r\n\r\n// 判断传入节点是否是静态的简单表达式节\r\nexport const isStaticExp = (p) => {\r\n  return p.type === NodeTypes.SIMPLE_EXPRESSION && p.isStatic;\r\n};\r\n\r\n// 判断传入节点是否是文本节点或插值节点\r\nexport const isText = (node) => {\r\n  return node.type === NodeTypes.INTERPOLATION || node.type === NodeTypes.TEXT;\r\n};\r\n","import { isOn, PatchFlagNames } from \"@vue/shared\";\r\nimport {\r\n  createCallExpression,\r\n  createObjectExpression,\r\n  createObjectProperty,\r\n  createSimpleExpression,\r\n  createVNodeCall,\r\n  ElementTypes,\r\n  NodeTypes,\r\n} from \"../ast\";\r\nimport { isStaticExp } from \"../utils\";\r\nimport { PatchFlags } from \"@vue/shared\";\r\n// 负责创建 codegenNode 的函数，主要工作有处理 props、children、patchFlag然后最终返回一个codegenNode 对象\r\nexport const transformElement = (node, context) => { \r\n    return function postTransformElement() { //需要返回一个退出函数\r\n      node = context.currentNode;\r\n  \r\n      // 只对元素节点进行处理\r\n      if (node.type !== NodeTypes.ELEMENT) {\r\n        return;\r\n      }\r\n  \r\n      // 初始化如下变量\r\n      const { tag, props } = node;\r\n      const isComponent = node.tagType === ElementTypes.COMPONENT;\r\n  \r\n      let vnodeTag = `\"${tag}\"`;\r\n      let vnodeProps;\r\n      let vnodeChildren;\r\n      let vnodePatchFlag;\r\n      let patchFlag = 0;\r\n      let vnodeDynamicProps;\r\n      let dynamicPropNames;\r\n      let vnodeDirectives;\r\n  \r\n      // TODO 处理 props\r\n      // 获取属性解析结果\r\n      const propsBuildResult = buildProps(node, context);\r\n      vnodeProps = propsBuildResult.props;\r\n      patchFlag = propsBuildResult.patchFlag;\r\n      dynamicPropNames = propsBuildResult.dynamicPropNames;\r\n      vnodeDirectives = propsBuildResult.directives;\r\n\r\n\r\n      // TODO 处理 children\r\n    if (node.children.length > 0) {\r\n        if (node.children.length === 1) {\r\n          const child = node.children[0];\r\n          const type = child.type;\r\n        \r\n          // 分析是否存在动态文本子节点，插值表达式和复合文本节点\r\n          const hasDynamicTextChild =\r\n            type === NodeTypes.INTERPOLATION ||\r\n            type === NodeTypes.COMPOUND_EXPRESSION;\r\n        \r\n          // 有动态文本子节点则修改 patchFlag\r\n          if (hasDynamicTextChild) {\r\n            patchFlag |= PatchFlags.TEXT;\r\n          }\r\n      \r\n          // 获取 vnodeChildren\r\n          // type === NodeTypes.TEXT判断一个AST节点的类型是不是纯静态文本节点\r\n          if (hasDynamicTextChild || type === NodeTypes.TEXT) {\r\n            vnodeChildren = child;\r\n          } else {\r\n            vnodeChildren = node.children;\r\n          }\r\n        } else {\r\n          vnodeChildren = node.children;\r\n        }\r\n      }\r\n  \r\n\r\n      // TODO 处理 patchFlag\r\n\r\n\r\n      if (patchFlag !== 0) {\r\n        // patchFlag 为负数则说明不存在复合情况\r\n        if (patchFlag < 0) {\r\n          vnodePatchFlag = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`;\r\n        }\r\n      \r\n        // patchFlag 为正数说明可能存在复合情况，特殊处理\r\n        else {\r\n          const flagNames =\r\n            // 获取 PatchFlagNames 中所有的键名\r\n            Object.keys(PatchFlagNames)\r\n              // 全部转换为 Number 类型\r\n              .map(Number)\r\n              // 只保留 patchFlag 中存在的，并且值大于 0 的\r\n              .filter((n) => n > 0 && patchFlag & n)// patchFlag & n：当前 patchFlag 包含这个标志位（按位与成立）\r\n              // 将 patchFlag 数值转换成对应 patchFlag 名称\r\n              .map((n) => PatchFlagNames[n])\r\n              // 用逗号连接\r\n              .join(\", \");\r\n      \r\n          // 将上面的内容注释在 patchFlag 后面作为一个参考\r\n          vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;\r\n        }\r\n      \r\n        // TODO 处理动态属性名\r\n        if (dynamicPropNames && dynamicPropNames.length) {\r\n            vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);\r\n        }\r\n      }\r\n      \r\n      node.codegenNode = createVNodeCall(\r\n        node.type,\r\n        vnodeTag,\r\n        vnodeProps,\r\n        vnodeChildren,\r\n        vnodePatchFlag,\r\n        vnodeDynamicProps,\r\n        vnodeDirectives,\r\n        isComponent\r\n      );\r\n    };\r\n};\r\n  \r\n\r\n\r\n// 处理 props(这里跟源码的处理不同，源码的parse将所有属性都处理成了props，我们前面实现的parse分开处理props和directives)\r\n// 所以可以将directives也合并到props中，这样就可以一起处理了\r\nconst buildProps = (\r\n    node,\r\n    context,\r\n    props = [...node.props, ...node.directives]\r\n  ) => {\r\n    // 初始化一些变量\r\n    const isComponent = node.tagType === ElementTypes.COMPONENT;\r\n    let properties = []; // 遍历 props 生成的属性数组\r\n    const mergeArgs = []; // 用于存储需要合并到组件属性中的参数。比如在 Vue 中，可以通过 v-bind 或者简写 : 来绑定一个对象作为组件的属性，这些对象的属性需要被合并到最终的属性对象中。\r\n    const runtimeDirectives = []; // 用于存储运行时指令。在 Vue 中，指令（如 v-if, v-for, v-model 等）是特殊的标记，它们会在运行时对 DOM 元素进行额外的处理。这个数组将存储这些指令的相关信息。\r\n  \r\n    // 再初始化一些变量\r\n    let patchFlag = 0; // 用于标记属性是否发生了变化，以及变化的类型。用于 diff算法。\r\n    // 这两个布尔值用于标记节点是否有绑定的 class 或 style 属性。这些属性在 Vue 中是特殊的，因为它们可以绑定一个对象或者数组，而不是单个的字符串。\r\n    let hasClassBinding = false;\r\n    let hasStyleBinding = false;\r\n    let hasHydrationEventBinding = false; // 用于标记是否有事件绑定需要在 hydration（Vue 3 中的服务器端渲染过程中的客户端激活）阶段处理。\r\n    let hasDynamicKeys = false; // 用于标记是否有动态 key 属性，这对于列表渲染和虚拟 DOM 的高效更新非常重要。\r\n    const dynamicPropNames = []; // 用于存储动态绑定的属性名。\r\n  \r\n    // analyzePatchFlag 在下面的属性遍历中被用于处理内置指令，来为后面的 patchFlag 分析过程提供参照标准\r\n    const analyzePatchFlag = ({ key }) => {\r\n        // isStatic 会判断传入节点是否是静态的简单表达式节点 (SIMPLE_EXPRESSION)\r\n        if (isStaticExp(key)) {\r\n          const name = key.content;\r\n          // isOn 会判断传入属性是否是 onXxxx 事件注册\r\n          const isEventHandler = isOn(name);\r\n        \r\n          if (\r\n            !isComponent &&\r\n            isEventHandler && //当前属性是事件处理函数 是不是事件监听器 比如@click->onClick\r\n            //toLowerCase()大写字母转换为小写字母\r\n            name.toLowerCase() !== \"onclick\" // 特别排除掉 onClick，因为在 SSR 模式下，onClick 事件行为特殊（比如内联脚本攻击风险）。\r\n            // 源码这里还会忽略 v-model 双向绑定\r\n            // 源码这里还会忽略 onVnodeXXX hooks\r\n          ) {\r\n            hasHydrationEventBinding = true;// 标记当前 VNode 在 hydration 时需要附加事件\r\n          }\r\n      \r\n          // 源码在这里会忽略 cacheHandler 以及有静态值的属性\r\n      \r\n          // 这里根据属性的名称进行分析\r\n          if (name === \"class\") {\r\n            hasClassBinding = true;\r\n          } else if (name === \"style\") {\r\n            hasStyleBinding = true;\r\n          } else if (name !== \"key\" && !dynamicPropNames.includes(name)) { //收集“动态属性名”，但排除 key 属性和已经添加过的属性名\r\n            dynamicPropNames.push(name);\r\n          }\r\n      \r\n          // 将组件上绑定的类名以及样式视为动态属性\r\n          if (\r\n            isComponent &&\r\n            (name === \"class\" || name === \"style\") &&\r\n            !dynamicPropNames.includes(name)\r\n          ) {\r\n            dynamicPropNames.push(name);\r\n          }\r\n        } else {\r\n          // 属性名不是简单表达式 (SIMPLE_EXPRESSION) 的话\r\n          // 则视为有动态键名\r\n          hasDynamicKeys = true;\r\n        }\r\n    };\r\n\r\n    // 将静态属性筛选出来并封装成相应的节点\r\n    for (let i = 0; i < props.length; i++) {\r\n        const prop = props[i];\r\n        // 处理静态属性static attribute\r\n        if (prop.type === NodeTypes.ATTRIBUTE) {\r\n          const { name, value } = prop;\r\n          let valueNode = createSimpleExpression(value || \"\", true);\r\n      \r\n          properties.push(\r\n            createObjectProperty(createSimpleExpression(name, true), valueNode)\r\n          );\r\n        } else {\r\n          // TODO 处理指令directives\r\n          const { name, arg, exp } = prop;\r\n          const isVBind = name === \"bind\";\r\n          const isVOn = name === \"on\";\r\n                  \r\n          // 源码这里会跳过以下指令\r\n          // v-slot\r\n          // v-once/v-memo\r\n          // v-is/:is\r\n          // SSR 环境下的 v-on\r\n                  \r\n          // 处理无参数的 v-bind 以及 v-on（比如 v-bind=\"obj\"此时上面绑定的内容可以动态更换，有参数的情况是 v-bind:xxx=\"obj\"）\r\n          if (!arg && (isVBind || isVOn)) {\r\n          // 有动态的键\r\n            hasDynamicKeys = true;\r\n                  \r\n            // 有值的话，则进行处理\r\n            if (exp) {//  如果有表达式（例如 v-bind=\"obj\" 中的 obj），则说明需要合并。\r\n              if (properties.length) {// 如果前面已经积累了一些静态或普通 props（如 :id=\"foo\"、:class=\"bar\"），先将它们打包成一个对象表达式，加入合并参数中。然后清空 properties，准备下一个合并。\r\n                mergeArgs.push(createObjectExpression(properties));\r\n                properties = [];\r\n              }\r\n\r\n              if (isVBind) {\r\n                // 是 v-bind\r\n                mergeArgs.push(exp);\r\n              } else { \r\n                // 是 v-on\r\n                mergeArgs.push({\r\n                  type: NodeTypes.JS_CALL_EXPRESSION,\r\n                  arguments: [exp],\r\n                });\r\n              }\r\n            }\r\n            continue;\r\n          }\r\n\r\n          // 运行时指令处理\r\n          // context.directiveTransforms 是 Vue 编译器内部提供的一个 “内置指令转换器表”，是一个对象，键是指令名（不带v-），值是一个转换函数（也叫directiveTransform）\r\n          const directiveTransform = context.directiveTransforms[name];// 尝试获取这个指令名，（如 model、show）对应的内置指令处理函数。\r\n          if (directiveTransform) {\r\n            // 内置指令\r\n            // props: 静态属性节点数组（用于 patch diff 和 DOM 渲染）；needRuntime: 是否仍然需要在运行时处理（如 v-model 还需要动态绑定事件）。\r\n            const { props, needRuntime } = directiveTransform(prop, node, context);\r\n            // 每个属性都去执行一遍 analyzePatchFlag\r\n            props.forEach(analyzePatchFlag);\r\n            properties.push(...props);\r\n            if (needRuntime) {\r\n              runtimeDirectives.push(prop);\r\n            }\r\n          } else {\r\n            // 自定义指令\r\n            runtimeDirectives.push(prop);// 如果是自定义指令（如 v-focus, v-permission），Vue 编译器不懂，只能保留原样并标记它需要运行时处理。\r\n          }\r\n\r\n\r\n        }\r\n    }\r\n      \r\n  \r\n    // 合并参数\r\n    // 在这一步会根据参数不同进一步进行封装，mergeArgs 只会在处理无参数的 v-bind、v-on 时才会进行处理，因此这一步合并的其实就是 v-bind 和 v-on 。\r\n    let propsExpression = undefined; // propsExpression 是一个表达式，它代表了组件的属性（props）的最终形式。\r\n    // 如果有 v-bind\r\n    if (mergeArgs.length) {\r\n      // 如果有其他属性，那么将它们合并到 mergeArgs 中，因为最终的 propsExpression 是通过 mergeArgs 创建的。\r\n      if (properties.length) {\r\n        mergeArgs.push(createObjectExpression(properties));\r\n      }\r\n\r\n      if (mergeArgs.length > 1) {// 如果需要合并多个对象（mergeArgs.length > 1），就创建一个函数调用表达式,比如Object.assign({}, obj1, obj2, obj3)\r\n        propsExpression = createCallExpression(mergeArgs);\r\n      } else {\r\n        // 只有一个 v-bind,就直接使用，不需要合并\r\n        propsExpression = mergeArgs[0];\r\n      }\r\n    } else if (properties.length) { // 如果没有v-bind 等，只是普通静态属性，那就用 createObjectExpression(properties) 生成一个对象：\r\n      propsExpression = createObjectExpression(properties);\r\n    }\r\n\r\n\r\n  \r\n    // TODO 分析 patchFlag\r\n    if (hasDynamicKeys) { // 判断是不是有动态的Key\r\n        patchFlag |= PatchFlags.FULL_PROPS;// FULL_PROPS（全属性都需要 patch）。\r\n      } else {\r\n        if (hasClassBinding && !isComponent) {\r\n          patchFlag |= PatchFlags.CLASS;\r\n        }\r\n        if (hasStyleBinding && !isComponent) {\r\n          patchFlag |= PatchFlags.STYLE;\r\n        }\r\n        if (dynamicPropNames.length) {// 有指定属性变化\r\n          patchFlag |= PatchFlags.PROPS;\r\n        }\r\n        if (hasHydrationEventBinding) {\r\n          patchFlag |= PatchFlags.NEED_HYDRATION;\r\n        }\r\n    }\r\n      \r\n      // 这里在源码中还会考虑 ref 以及 vnodeHook\r\n    if (\r\n        (patchFlag === 0 || patchFlag === PatchFlags.NEED_HYDRATION) &&\r\n        runtimeDirectives.length > 0\r\n    ) {\r\n        patchFlag |= PatchFlags.NEED_PATCH;//Vue 为了确保指令如 v-show, v-model 这类运行时处理的逻辑能生效，即使这个节点看起来是“静态的”，也需要 patch 一次。 \r\n    }\r\n      \r\n    // TODO 规范化 props\r\n    if (propsExpression) {// 只有存在 propsExpression 才继续处理，propsExpression 是一个 AST 节点，表示组件的属性表达式。\r\n        switch (propsExpression.type) {\r\n          // 说明 props 中没有 v-bind，只需要处理动态的属性绑定\r\n          case NodeTypes.JS_OBJECT_EXPRESSION://JS对象表达式\r\n            let classKeyIndex = -1;\r\n            let styleKeyIndex = -1;\r\n            let hasDynamicKey = false;\r\n      \r\n            // 遍历所有 props，获取类名以及样式的索引\r\n            // 并判断是否有动态键名\r\n            for (let i = 0; i < propsExpression.properties.length; i++) {\r\n              const key = propsExpression.properties[i].key;\r\n              // 是静态键名\r\n              if (isStaticExp(key)) {\r\n                if (key.content === \"class\") {\r\n                  classKeyIndex = i;\r\n                } else if (key.content === \"style\") {\r\n                  styleKeyIndex = i;\r\n                }\r\n              }\r\n              // 是动态键名\r\n              else if (!key.isHandlerKey) {\r\n                hasDynamicKey = true;\r\n              }\r\n            }\r\n      \r\n            const classProp = propsExpression.properties[classKeyIndex];\r\n            const styleProp = propsExpression.properties[styleKeyIndex];\r\n      \r\n            // 没有动态键名\r\n            if (!hasDynamicKey) {\r\n              // 类名的值是动态的话则包装一下类名的值\r\n              if (classProp && !isStaticExp(classProp.value)) {\r\n                classProp.value = createCallExpression([classProp.value]);\r\n              }\r\n      \r\n              // 样式的值是动态的则包装一下样式的值\r\n              // styleprop表示 props 对象中是否存在 style 属性。<div :style=\"myStyle\" />会被转换成  style: myStyle，此时styleProp 就是这个对象属性节点\r\n              if (\r\n                styleProp &&\r\n                !isStaticExp(styleProp.value) &&\r\n                (hasStyleBinding ||\r\n                  styleProp.value.type === NodeTypes.JS_ARRAY_EXPRESSION)// 这一行，表示样式是数组形式的绑定，比如:style=\"[style1, style2]\"，这种情况 value 是一个数组表达式（JS_ARRAY_EXPRESSION），需要在运行时进行合并解析。\r\n              ) {\r\n                styleProp.value = createCallExpression([styleProp.value]);\r\n              }\r\n            }\r\n      \r\n            // 有动态键名则直接包装整个 propsExpression\r\n            else {\r\n              propsExpression = createCallExpression([propsExpression]);\r\n            }\r\n            break;\r\n      \r\n          // 合并属性，不需要处理\r\n          case NodeTypes.JS_CALL_EXPRESSION:\r\n            break;\r\n      \r\n          // 只有 v-bind 直接包装整个 propsExpression\r\n          default:\r\n            propsExpression = createCallExpression([\r\n              createCallExpression([propsExpression]),\r\n            ]);\r\n            break;\r\n        }\r\n      }\r\n    // 返回结果\r\n    return {\r\n        props: propsExpression,\r\n        directives: runtimeDirectives,\r\n        patchFlag,\r\n        dynamicPropNames,\r\n    };\r\n};\r\n  \r\n\r\n\r\n// 遍历所有节点并转换成数组结构的字符串返回\r\nconst stringifyDynamicPropNames = (props) => {\r\n    let propsNamesString = \"[\";\r\n    for (let i = 0, l = props.length; i < l; i++) {\r\n      propsNamesString += JSON.stringify(props[i]);\r\n      if (i < l - 1) propsNamesString += \",\";\r\n    }\r\n    return propsNamesString + \"]\";\r\n};\r\n  \r\n\r\n","import { NodeTypes } from \"../ast\";\r\nimport { isText } from \"../utils\";\r\n\r\n// 处理组合表达式\r\nexport const transformText = (node) => {\r\n    // 只有元素节点和根节点需要处理\r\n    if (node.type === NodeTypes.ROOT || node.type === NodeTypes.ELEMENT) {\r\n      return function postTransformText() {\r\n        console.log(\"调用transformText方法处理组合表达式，当前节点为\", node);\r\n        const children = node.children;\r\n        let currentContainer = undefined;\r\n        let hasText = false;\r\n  \r\n        // 遍历查找文本/插值表达式节点\r\n        for (let i = 0; i < children.length; i++) {\r\n          const child = children[i];\r\n          // 找到则将 hasText 置为 true 并查找后面的节点\r\n          if (isText(child)) {\r\n            hasText = true;\r\n            // 查找后面的节点\r\n            for (let j = i + 1; j < children.length; j++) {\r\n              const next = children[j];\r\n              // 找到了则进行合并\r\n              if (isText(next)) {\r\n                if (!currentContainer) {\r\n                  currentContainer = children[i] = {\r\n                    type: NodeTypes.COMPOUND_EXPRESSION,\r\n                    children: [child],\r\n                  };\r\n                }\r\n  \r\n                // 合并相邻文本/插值表达式节点到 currentContainer 内，currentContainer 只是children[i]的一个引用，改变currentContainer的值，children[i]也会改变\r\n                currentContainer.children.push(next);\r\n                children.splice(j, 1);\r\n                j--;\r\n              } else {\r\n                // 没找到就直接退出\r\n                currentContainer = undefined;\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        }\r\n        console.log(\"处理组合表达式后的结果currentContainer\", currentContainer);\r\n      };\r\n    }\r\n};\r\n  \r\n","import { capitalize, toHandlerKey } from \"@vue/shared\";\r\nimport {\r\n  createObjectProperty,\r\n  createSimpleExpression,\r\n  NodeTypes,\r\n} from \"../ast\";\r\n//v-on 需要驼峰化事件监听、处理事件监听缓存、应用拓展插件等\r\n//简化之后的transformOn要做的事情非常简单，只需要驼峰化事件监听，然后包装成 JS_PROPERTY 类型的对象返回即可\r\n\r\n// 处理 v-on 指令\r\nexport const transformOn = (dir) => { // dir是一个描述v-on指令的节点对象\r\n    const { arg } = dir;\r\n  \r\n    // 驼峰化\r\n    let eventName;\r\n    if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n      if (arg.isStatic) {\r\n        const rawName = arg.content; //获取事件名字符串，如 \"click\"。\r\n        eventName = createSimpleExpression(\r\n          toHandlerKey(capitalize(rawName)),//capitalize(rawName)：把事件名首字母大写;  toHandlerKey(\"Click\")：添加 on 前缀;  createSimpleExpression(\"onClick\", true)：包装成一个静态表达式节点。  \r\n          true\r\n        );\r\n      }\r\n      // 源码在这里将动态的事件名处理成组合表达式\r\n    } else {\r\n      eventName = arg;\r\n    }\r\n  \r\n    // 处理表达式\r\n    let exp = dir.exp;// 获取指令绑定的表达式（handler 函数名）：例子：@click=\"doSomething\" → exp.content === \"doSomething\"\r\n    if (exp && !exp.content.trim()) { // 如果exp存在但是空字符串\r\n      exp = undefined;\r\n    }\r\n    // 源码在这里会处理事件缓存\r\n    // 源码在这里会处理外部插件 extended compiler augmentor\r\n  \r\n    // 包装并返回 JS_PROPERTY 节点\r\n    const ret = {\r\n      props: [\r\n        createObjectProperty( //生成形如 { key: value } 的 AST 结构。\r\n          eventName,\r\n          exp || createSimpleExpression(\"() => {}\", false) //exp：处理函数表达式，如 \"handleClick\"；如果为空就用 () => {} 兜底（避免运行时报错）\r\n        ),\r\n      ],\r\n    };\r\n    return ret;\r\n};\r\n  \r\n","import {\r\n    createObjectProperty,\r\n    createSimpleExpression,\r\n    NodeTypes,\r\n  } from \"../ast\";\r\n// 处理 v-bind 指令\r\nexport const transformBind = (dir) => {\r\n    // dir 是指令对象，包含如 exp（表达式）和 arg（属性名）等信息。v-bind:class=\"myClass\" 中：dir.arg.content === \"class\";dir.exp.content === \"myClass\"\r\n    const { exp } = dir;\r\n    const arg = dir.arg;\r\n  \r\n    // 容错处理，如果为空则输出一个空字符串\r\n    // 因为 arg 是一个简单的表达式，并且是动态的（因为它的值可能会改变），所以 transformBind 函数会在 myClass 前后添加条件运算符||，\r\n    // 以确保如果 myClass 的值为 undefined 或''（空字符串），它将返回一个空字符串而不是错误。（即容错处理）\r\n\r\n    if (arg.type !== NodeTypes.SIMPLE_EXPRESSION) {\r\n      arg.children.unshift(\"(\");//动态 key 的安全处理：将表达式包装为 (foo) || \"\"，防止 foo 为 undefined 时报错。\r\n      arg.children.push(') || \"\"');\r\n    } else if (!arg.isStatic) {\r\n      arg.content = `${arg.content} || \"\"`;\r\n    }\r\n  \r\n    // 包装并返回 JS_PROPERTY 节点\r\n    if (\r\n      !exp ||\r\n      (exp.type === NodeTypes.SIMPLE_EXPRESSION && !exp.content.trim())\r\n    ) {\r\n      return {\r\n        props: [createObjectProperty(arg, createSimpleExpression(\"\", true))],// createSimpleExpression(\"\", true) 表示一个静态空字符串表达式。\r\n      };\r\n    }\r\n  \r\n    const ret = {\r\n      props: [createObjectProperty(arg, exp)],\r\n    };\r\n  \r\n    return ret;\r\n    // 最终，transformBind 函数会返回一个新的对象，它包含了一个属性，这个属性的键是带有前缀的属性名（.class），值是我们的表达式（myClass）。（即包装节点）\r\n\r\n  };\r\n","import { isObject } from \"@vue/shared\";\r\nimport { NodeTypes } from \"./ast\";\r\n// codegen 代码生成\r\nexport const generate = (ast) => {\r\n    // 获取上下文（包含生成代码所需的状态和工具函数）\r\n    const context = createCodegenContext();\r\n    // push用于添加代码到上下文中，indent和deindent用于增加或减少代码的缩进级别。\r\n    const { push, indent, deindent } = context; //解构出三个函数\r\n    //context.code是字符串缓冲区，用于收集最终形成的js渲染函数代码\r\n  \r\n    indent();// 增加当前代码缩进层级，使输出的代码格式化美观。\r\n\r\n    // vue编译器的目标，是把我的模版编译成js渲染函数->  return h(\"div\", null, ctx.count)\r\n    // 但是但 Vue 不想手动在每个地方都加 ctx.，太麻烦、代码冗余。因此它用了 JavaScript 的 with 语句：\r\n    // with (ctx) { ... } 表示，把 ctx 这个对象的属性当作局部变量来用。\r\n    // 如果你写 with(ctx){console.log(count)}，虽然count没有声明，但是JS会在ctx中查找属性，等价于console.log(ctx.count);\r\n\r\n\r\n    push(\"with (ctx) {\"); // with语句用于确保ctx中的属性和方法可以在代码块内部直接访问，用于后面的new Function生成代码(因此此时生成的是字符串，里面的h函数、渲染的值以及函数等都需要传入)\r\n    indent(); // 再次缩进，进入 with 语句内部\r\n  \r\n    push(\"return function render(){return \");\r\n    if (ast.codegenNode) {\r\n      genNode(ast.codegenNode, context); // 递归生成代码\r\n    } else {\r\n      push(\"null\");\r\n    }\r\n  \r\n    deindent();\r\n    push(\"}}\");\r\n  \r\n    return {\r\n      ast,\r\n      code: context.code,\r\n    };\r\n  };\r\n  \r\n\r\n\r\n// 获取上下文\r\nconst createCodegenContext = () => {\r\n    const context = {\r\n      // state\r\n      code: \"\", // 目标代码   字符串，储存了最终生成的代码内容\r\n      indentLevel: 0, // 缩进等级\r\n  \r\n      // method\r\n      push(code) { // 追加代码片段\r\n        context.code += code;\r\n      },\r\n      indent() { // 用于增加缩进级别，表示进入一个新的代码块。作用是调用 newline 函数，传入增加后的缩进等级。\r\n        newline(++context.indentLevel);\r\n      },\r\n      deindent(witoutNewLine = false) {// witoutNewLine 为 false（默认），会调用 newline 方法，先减小缩进，再添加换行符。\r\n        if (witoutNewLine) { // witoutNewLine 为 true，则只减小缩进，而不会添加换行符。\r\n          --context.indentLevel;\r\n        } else {\r\n          newline(--context.indentLevel);\r\n        }\r\n      },\r\n      newline() { // newline() 方法调用时，实际上是通过调用 newline(context.indentLevel)，将当前的 indentLevel（缩进级别）传递给局部的 newline(n) 函数。\r\n        newline(context.indentLevel);// 这一步的目的是封装 newline(n)，方便后续使用，只需要调用 newline() 就能自动传递 indentLevel。\r\n      },\r\n    };\r\n    function newline(n) {\r\n      context.push(\"\\n\" + \"  \".repeat(n));// \" \".repeat(n) 会生成 n 个空格\r\n    }\r\n    return context;\r\n};\r\n\r\n\r\n\r\n// 生成代码\r\nconst genNode = (node, context) => {\r\n    // 如果是字符串就直接 push\r\n    if (typeof node === \"string\") {\r\n      context.push(node);\r\n      return;\r\n    }\r\n  \r\n    switch (node.type) {\r\n      case NodeTypes.ELEMENT:\r\n        genElement(node, context);\r\n        break;\r\n      case NodeTypes.TEXT:\r\n      case NodeTypes.INTERPOLATION:\r\n        genTextData(node, context);\r\n        break;\r\n      case NodeTypes.COMPOUND_EXPRESSION:\r\n        genCompoundExpression(node, context);\r\n        break;\r\n    }\r\n};\r\n  \r\n\r\n// 生成元素节点\r\nconst genElement = (node, context) => {\r\n    const { push, deindent } = context;\r\n    const { tag, children, props } = node;\r\n  \r\n    // tag\r\n    push(`h(${tag}, `);// 用来生成虚拟 DOM 节点的 h 函数调用。虚拟 DOM 中的元素通常通过 h(tag, props, children) 来创建。\r\n  \r\n    // props\r\n    if (props) {\r\n      genProps(props.properties, context);\r\n    } else {\r\n      push(\"null, \");// 表示没有子节点\r\n    }\r\n  \r\n    // children\r\n    if (children) {\r\n      genChildren(children, context);\r\n    } else {\r\n      push(\"null\");\r\n    }\r\n  \r\n    deindent();\r\n    push(\")\");\r\n};\r\n\r\n\r\n// genProps要做的就是获取节点中的属性数据，并拼接成一个对象的样子push进目标代码\r\nconst genProps = (props, context) => {\r\n    const { push } = context;\r\n  \r\n    if (!props.length) {\r\n      push(\"{}\");\r\n      return;\r\n    }\r\n  \r\n    push(\"{ \");\r\n    for (let i = 0; i < props.length; i++) {\r\n      // 遍历每个 prop 对象，获取其中的 key 节点和 value 节点\r\n      const prop = props[i];\r\n      const key = prop ? prop.key : \"\";\r\n      const value = prop ? prop.value : prop;\r\n  \r\n      if (key) {\r\n        // key\r\n        genPropKey(key, context);\r\n        // value\r\n        genPropValue(value, context);\r\n      } else {\r\n        // 如果 key 不存在就说明是一个 v-bind\r\n        // ↑当 Vue 处理 v-bind 时，会把属性名作为一个动态的表达式来处理，而不是一个普通的字符串常量。所以，通常在编译过程中，当遇到没有静态 key 的情况时，就可以推测出这是一个 v-bind 的动态属性。\r\n        const { content, isStatic } = value;\r\n        const contentStr = JSON.stringify(content);\r\n        push(`${contentStr}: ${isStatic ? contentStr : content}`);\r\n      }\r\n  \r\n      if (i < props.length - 1) {\r\n        push(\", \");\r\n      }\r\n    }\r\n    push(\" }, \");\r\n  };\r\n  \r\n  // 生成键\r\n  const genPropKey = (node, context) => {\r\n    const { push } = context;\r\n    const { isStatic, content } = node;\r\n    push(isStatic ? JSON.stringify(content) : content);\r\n    push(\": \");\r\n  };\r\n  \r\n  // 生成值\r\n  const genPropValue = (node, context) => {\r\n    const { push } = context;\r\n    const { isStatic, content } = node;\r\n    push(isStatic ? JSON.stringify(content.content) : JSON.stringify(content));\r\n};\r\n  \r\n  \r\n// 生成子节点\r\nconst genChildren = (children, context) => {\r\n    const { push, indent } = context;\r\n  \r\n    push(\"[\");\r\n    indent();\r\n  \r\n    // 单独处理 COMPOUND_EXPRESSION\r\n    if (children.type === NodeTypes.COMPOUND_EXPRESSION) {\r\n      genCompoundExpression(children, context);\r\n    }\r\n  \r\n    // 单独处理 TEXT\r\n    else if (isObject(children) && children.type === NodeTypes.TEXT) {\r\n      genNode(children, context);\r\n    }\r\n  \r\n    // 其余节点直接递归\r\n    else {\r\n      for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        genNode(child.codegenNode || child.children, context);\r\n        push(\", \");\r\n      }\r\n    }\r\n  \r\n    push(\"]\");\r\n};\r\n\r\n\r\n// 生成文本节点和插值表达式节点\r\nconst genTextData = (node, context) => {\r\n    const { push } = context;\r\n    const { type, content } = node;\r\n  \r\n    // 如果是文本节点直接拿出 content\r\n    // 如果是插值表达式需要拿出 content.content，因为插值表达式节点在vue中是一个嵌套结构\r\n    const textContent =\r\n      type === NodeTypes.TEXT\r\n        ? JSON.stringify(content)\r\n        : NodeTypes.INTERPOLATION\r\n        ? content.content\r\n        : \"\";\r\n  \r\n    if (type === NodeTypes.TEXT) {\r\n      push(textContent);\r\n    }\r\n    if (type === NodeTypes.INTERPOLATION) {\r\n      push(\"`${\");\r\n      push(`${textContent}`);\r\n      push(\"}`\");\r\n    }\r\n};\r\n  \r\n// 生成复合表达式\r\nconst genCompoundExpression = (node, context) => {\r\n    const { push } = context;\r\n    for (let i = 0; i < node.children.length; i++) {\r\n      const child = node.children[i];\r\n      if (typeof child === \"string\") {\r\n        push(child);\r\n      } else {\r\n        genNode(child, context);\r\n      }\r\n  \r\n      if (i !== node.children.length - 1) {\r\n        push(\", \");\r\n      }\r\n    }\r\n};\r\n  \r\n\r\n  \r\n","import { extend, isString } from \"@vue/shared\";\r\nimport { baseParse } from \"./parse\";\r\nimport { transform } from \"./transform\";\r\nimport { transformElement } from \"./transforms/transformElement\";\r\nimport { transformText } from \"./transforms/transformText\";\r\nimport { transformOn } from \"./transforms/vOn\";\r\nimport { transformBind } from \"./transforms/vBind\";\r\nimport { generate } from \"./codegen\";\r\n\r\nexport const getBaseTransformPreset: () => [any[], {}] = () => {\r\n  // 插件预设\r\n  return [\r\n    [transformElement, transformText],\r\n    {\r\n      on: transformOn,\r\n      bind: transformBind,\r\n    },\r\n  ];\r\n};\r\n\r\n// 完整编译过程：template -> ast -> codegen -> render\r\nexport const baseCompile = (template, options: any = {}) => {\r\n  // 第一步：将模板字符串转换成AST\r\n  const ast = isString(template) ? baseParse(template) : template;\r\n  // 第二步：AST加工\r\n  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();\r\n  transform(\r\n    ast,\r\n    extend({}, options, {\r\n      nodeTransforms: [...nodeTransforms, ...(options.nodeTransforms || [])],\r\n      directiveTransforms: extend(\r\n        {},\r\n        directiveTransforms,\r\n        options.directiveTransforms || {} // user transforms\r\n      ),\r\n    })\r\n  );\r\n  // 第三步：将AST转换成渲染函数，最终得到一个render渲染函数\r\n  return generate(ast);\r\n};\r\n"],"names":[],"mappings":"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"}
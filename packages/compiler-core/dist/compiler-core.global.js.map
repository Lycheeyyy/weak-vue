{"version":3,"file":"compiler-core.global.js","sources":["../src/ast.ts","../src/parse.ts","../src/transform.ts","../src/utils.ts","../src/transforms/transformElement.ts","../src/transforms/transformText.ts","../src/transforms/vOn.ts","../src/transforms/vBind.ts","../src/codegen.ts","../src/compile.ts"],"sourcesContent":["import { isString } from \"@vue/shared\";\r\n// AST节点类型\r\nexport const enum NodeTypes {\r\n  // AST节点类型\r\n  ROOT, // 表示根节点\r\n  ELEMENT, // 表示元素节点，可能是div、span等原生标签，也可能是自定义组件\r\n  TEXT, // 表示文本节点\r\n  SIMPLE_EXPRESSION, // 表示简单表达式节点\r\n  ATTRIBUTE, // 表示属性节点\r\n  DIRECTIVE, // 表示指令节点\r\n  INTERPOLATION, // 表示插值节点\r\n\r\n  // 表示可以包含子节点的结构，比如元素节点、文本节点等\r\n  TEXT_CALL, // 表示文本节点中的插值节点，比如parse {{ element }}</div>中的{{ element }}\r\n  COMPOUND_EXPRESSION, // 表示复合表达式节点，比如{{ a + b }}中的a + b\r\n\r\n  // For codegen，用于代码生成\r\n  VNODE_CALL, // 表示创建VNode节点的代码\r\n  JS_PROPERTY, // 表示JS对象的属性\r\n  JS_CALL_EXPRESSION, // 表示JS的调用表达式\r\n  JS_ARRAY_EXPRESSION, // 表示JS的数组表达式\r\n  JS_OBJECT_EXPRESSION, // 表示JS的对象表达式\r\n}\r\n  \r\n// 标签类型\r\n//看标签时原生标签还是自定义组件——vue源码采用穷举加映射的思路\r\nexport const enum ElementTypes {\r\n    ELEMENT,\r\n    COMPONENT,\r\n  }\r\n\r\n// 创建AST的根节点\r\nexport const createRoot = (children) => {\r\n    return {\r\n      type: NodeTypes.ROOT,\r\n      children,\r\n    };\r\n  };\r\n\r\n\r\n/**\r\n * 下面是与创建codegenNode相关的工具函数\r\n */\r\n// 创建一个简单的表达式节点\r\nexport const createSimpleExpression = (content, isStatic = false) => {\r\n    return {\r\n      type: NodeTypes.SIMPLE_EXPRESSION,\r\n      content,\r\n      isStatic,\r\n    };\r\n};\r\n  // 创建一个对象属性节点\r\nexport const createObjectProperty = (key, value) => {\r\n    return {\r\n      type: NodeTypes.JS_PROPERTY,\r\n      key: isString(key) ? createSimpleExpression(key, true) : key,\r\n      value,\r\n    };\r\n};\r\n  // 创建一个函数调用表达式节点\r\nexport const createCallExpression = (args = []) => {\r\n    return {\r\n      type: NodeTypes.JS_CALL_EXPRESSION,\r\n      arguments: args,\r\n    };\r\n};\r\n  // 创建一个对象表达式节点\r\nexport const createObjectExpression = (properties) => {\r\n    return {\r\n      type: NodeTypes.JS_OBJECT_EXPRESSION,\r\n      properties,\r\n    };\r\n};\r\n  // 这个函数是用来生成 codegenNode 的\r\nexport const createVNodeCall = (\r\n    type,\r\n    tag,\r\n    props,\r\n    children,\r\n    patchFlag,\r\n    dynamicProps,\r\n    directives,\r\n    isComponent\r\n  ) => {\r\n    // 源码这里还会处理 helper，这里为了方便暂不处理\r\n    return {\r\n      // 源码这里是 type：NodeTypes.VNODE_CALL，这里为了方便后面处理直接赋值为原本的节点类型\r\n      type,\r\n      tag,\r\n      props,\r\n      children,\r\n      patchFlag,\r\n      dynamicProps,\r\n      directives,\r\n      isComponent,\r\n    };\r\n};\r\n  \r\n","import { isHTMLTag, isVoidTag } from \"@vue/shared\";\r\nimport { createRoot, ElementTypes, NodeTypes } from \"./ast\";\r\n\r\n// 创建parse解析上下文\r\nexport const createParserContext = (content) => { \r\n  return {\r\n    source: content, // 模板字符串\r\n    // 源码中还有很多\r\n    // 比如\r\n    // options,\r\n    // column: 1,\r\n    // line: 1,\r\n    // offset: 0,\r\n    // 但这里只用到了 source\r\n  };\r\n};\r\n\r\n// 生成完整的AST\r\nexport const baseParse = (content) => { //const content = \"<div><p>Hello</p></div>\";\r\n  const context = createParserContext(content);\r\n  // 具体的解析逻辑\r\n  const children = parseChildren(context); //真正开始递归解析 HTML 模板，返回所有子节点的数组 children。\r\n  return createRoot(children);//最终返回一个根节点包裹子节点，形成完整的AST结构\r\n};\r\n\r\n// 解析模板字符串\r\nconst parseChildren = (context) => {\r\n    // 具体的解析逻辑，需要调用多个工具函数根据实际情况解析\r\n    // 模版是一个长长的存在嵌套的字符串，我们需要递归的解析\r\n    const nodes = [];\r\n    while (!isEnd(context)) {\r\n      const s = context.source;\r\n  \r\n      let node;\r\n  \r\n      // 此处做了简化\r\n      // 源码这里有一大串的 if else if else\r\n      // 但是很多都是处理比如\r\n      // '<!--' '<!DOCTYPE' '<![CDATA['\r\n      // 还有很多容错处理\r\n  \r\n      // 以 < 开头则是元素\r\n      if (s[0] === \"<\") {\r\n        node = parseElement(context);\r\n      }\r\n      // 以 {{ 开头则是插值表达式\r\n      else if (startsWith(s, \"{{\")) {\r\n        node = parseInterpolation(context);\r\n      }\r\n      // 否则就是文本节点\r\n      else {\r\n        node = parseText(context);\r\n      }\r\n  \r\n      // 源码中写了个 pushNode 方法来控制，这里直接写出来了\r\n      nodes.push(node);\r\n    }\r\n  \r\n    return nodes;\r\n  };\r\n  \r\n\r\n// 解析元素节点\r\nconst parseElement = (context) => {\r\n    // 返回一个对象结构表示解析出来的元素节点\r\n    const element = parseTag(context);\r\n  \r\n    // 如果是自闭合标签就不用解析子节点和闭合标签了\r\n    // 但是 <br /> 合法，<br> 也是合法的\r\n    // 因此用 isVoidTag 判断一下\r\n    if (element.isSelfClosing || isVoidTag(element.tag)) {\r\n      return element;\r\n    }\r\n  \r\n    element.children = parseChildren(context);\r\n  \r\n    // 里面要负责一个功能：只是要分割掉闭合标签 </div>，因此不用接收\r\n    parseTag(context);\r\n  \r\n    return element;\r\n  };\r\n\r\n// 解析标签内容\r\n// 进来时长这样\r\n// <div class=\"a\" v-bind:b=\"c\">parse {{ element }}</div>\r\nconst parseTag = (context) => {\r\n    //其中 /?\t表示匹配 0 个或 1 个 /，用于区分起始标签和结束标签（如 <div> vs </div>）\r\n    //</?：匹配斜杠和标签名前面的可选斜杠（表示闭合标签）\r\n    //[a-z]\t标签名第一个字符必须是英文字母      [^\\t\\r\\n\\f />]*\t后面可以跟任意多个不是 空白字符、/ 或 > 的字符（即标签名的其它部分）\r\n    //i表示忽略大小写\r\n    const tagReg = /^<\\/?([a-z][^\\t\\r\\n\\f />]*)/i;\r\n\r\n    // tagReg.exec() 方法会返回一个数组作为匹配结果，其中第一个元素是整个匹配到的字符串，而后面的元素则是每个捕获组（如果有的话）匹配到的内容。\r\n    // 这时的 match 是 ['<div', 'div']\r\n    //match[0] 是 <div，而 match[1] 是 div——————>match[0] 总是完整匹配的那一段,match[1] 是括号 () 内捕获的那一段，也就是你想要的标签名。\r\n    const match = tagReg.exec(context.source);\r\n    const tag = match[1];\r\n\r\n    advanceBy(context, match[0].length);\r\n    advanceSpaces(context);\r\n\r\n    // 此时 context.source\r\n    // class=\"a\" v-bind:b=\"c\">parse {{ element }}</div>\r\n\r\n    // parseAttributes 下面再实现\r\n    const { props, directives } = parseAttributes(context);\r\n\r\n    // 此时 context.source 会变成\r\n    // >parse {{ element }}</div>\r\n\r\n    const isSelfClosing = startsWith(context.source, \"/>\");\r\n\r\n    // 分割掉 \"/>\" 或 \">\"\r\n    advanceBy(context, isSelfClosing ? 2 : 1);\r\n\r\n    // 判断是组件还是原生元素\r\n    const tagType = isHTMLTag(tag)\r\n      ? ElementTypes.ELEMENT\r\n      : ElementTypes.COMPONENT;\r\n  \r\n    return {\r\n      type: NodeTypes.ELEMENT,\r\n      tag,\r\n      tagType,\r\n      props,\r\n      directives,\r\n      isSelfClosing,\r\n      children: [],\r\n    };\r\n};\r\n\r\n// 解析所有属性\r\n// 进来时长这样\r\n// class=\"a\" v-bind:b=\"c\">parse {{ element }}</div>\r\nconst parseAttributes = (context) => {\r\n    const props = [];\r\n    const directives = [];\r\n  \r\n    // 循环解析\r\n    // 遇到 \">\" 或者 \"/>\" 或者 context.source 为空字符串了才停止解析\r\n    while (\r\n      context.source.length > 0 &&\r\n      !startsWith(context.source, \">\") &&\r\n      !startsWith(context.source, \"/>\")\r\n    ) {\r\n      // 调用前\r\n      // class=\"a\" v-bind:b=\"c\">parse {{ element }}</div>\r\n      // parseAttributes 下面再实现\r\n      const attr = parseAttribute(context);\r\n      // 调用后\r\n      // v-bind:b=\"c\">parse {{ element }}</div>\r\n  \r\n      if (attr.type === NodeTypes.DIRECTIVE) {\r\n        directives.push(attr);\r\n      } else {\r\n        props.push(attr);\r\n      }\r\n    }\r\n  \r\n    return { props, directives };\r\n};\r\n\r\n// 解析单个属性\r\n// 进来时长这样\r\n// class=\"a\" v-bind:b=\"c\">parse {{ element }}</div>\r\nconst parseAttribute = (context) => {\r\n    // 匹配属性名的正则\r\n    //^（在方括号里）表示“不匹配以下字符”。\r\n    const namesReg = /^[^\\t\\r\\n\\f />][^\\t\\r\\n\\f />=]*/;\r\n  \r\n    // match 这时是 [\"class\"]\r\n    const match = namesReg.exec(context.source);\r\n    const name = match[0];\r\n  \r\n    // 分割掉属性名和前面的空格\r\n    advanceBy(context, name.length);\r\n    advanceSpaces(context);\r\n    // context.source 这时是\r\n    // =\"a\" v-bind:b=\"c\">parse {{ element }}</div>\r\n  \r\n    let value;\r\n    if (startsWith(context.source, \"=\")) {\r\n      // 分割掉 \"=\"\r\n      advanceBy(context, 1);\r\n      advanceSpaces(context);\r\n  \r\n      // parseAttributeValue 负责解析属性值，后面再实现\r\n      // 调用前\r\n      // \"a\" v-bind:b=\"c\">parse {{ element }}</div>\r\n      value = parseAttributeValue(context);\r\n      advanceSpaces(context);\r\n      // 调用后\r\n      // v-bind:b=\"c\">parse {{ element }}</div>\r\n    }\r\n  \r\n    // 上面获取了属性名 name 和属性值 value\r\n    // TODO--解析指令\r\n    if (/^(:|@|v-[A-Za-z0-9-])/.test(name)) {//判断这个 name 是不是 Vue 的指令，比如 :xx / @xx / v-xxx\r\n      let dirName, argContent;\r\n  \r\n    // 类似 <div :a=\"b\" />\r\n    if (startsWith(name, \":\")) {\r\n      dirName = \"bind\";\r\n      argContent = name.slice(1);//去掉冒号，拿到属性名 比如'a'\r\n    }\r\n  \r\n    // 类似 <div @click=\"a\" />\r\n    else if (startsWith(name, \"@\")) {\r\n      dirName = \"on\";\r\n      argContent = name.slice(1);\r\n    }\r\n  \r\n    // 类似 <div v-bind:a=\"b\" />\r\n    else if (startsWith(name, \"v-\")) {\r\n      [dirName, argContent] = name.slice(2).split(\":\");\r\n    }\r\n  \r\n    // 返回指令节点\r\n    return {\r\n      type: NodeTypes.DIRECTIVE,\r\n      name: dirName,\r\n      exp: value && {\r\n        type: NodeTypes.SIMPLE_EXPRESSION,\r\n        content: value,\r\n        isStatic: false,\r\n      },\r\n      arg: argContent && {\r\n        type: NodeTypes.SIMPLE_EXPRESSION,\r\n        content: argContent,\r\n        isStatic: true,\r\n      },\r\n    };\r\n  }\r\n\r\n};\r\n\r\n  // 获取属性值\r\n// 进来时是这样的\r\n// \"a\" v-bind:b=\"c\">parse {{ element }}</div>\r\nconst parseAttributeValue = (context) => {\r\n    // 获取引号的第一部分\r\n    const quote = context.source[0];\r\n  \r\n    // 分割掉引号的第一部分\r\n    // a\" v-bind:b=\"c\">parse {{ element }}</div>\r\n    advanceBy(context, 1);\r\n  \r\n    // 找到匹配的结尾引号\r\n    const endIndex = context.source.indexOf(quote);//.indexOf(...) 是 JavaScript 中字符串的一个 方法，用于查找某个字符或字符串在另一个字符串中第一次出现的位置（索引）。\r\n  \r\n    // 获取属性值\r\n    const content = parseTextData(context, endIndex);//会取出 context.source.slice(0, endIndex)，也就是 \"a\" 里的 a。\r\n  \r\n    // 分割掉结尾引号前面的部分\r\n    advanceBy(context, 1);\r\n  \r\n    return content;//最终返回属性值（不带引号的），如 \"a\" → a\r\n  };\r\n  \r\n  \r\n                                                                       \r\n  /**\r\n * ----------------解析文本节点parseInterpolation----------------\r\n */\r\n// 解析插值表达式\r\n// 进来时是这样的\r\n// {{ element }}</div>\r\nconst parseInterpolation = (context) => {\r\n    const [open, close] = [\"{{\", \"}}\"];\r\n  \r\n    advanceBy(context, open.length);\r\n    // 这时变成\r\n    //  element }}</div>\r\n  \r\n    // 找 \"}}\" 的索引\r\n    const closeIndex = context.source.indexOf(close, open.length);\r\n  \r\n    const content = parseTextData(context, closeIndex).trim();//trim() 是 JavaScript 字符串的方法，用来 删除字符串两端的空白字符（不包括中间的）\r\n    advanceBy(context, close.length);\r\n    // 这时变成\r\n    // </div>\r\n  \r\n    return {\r\n      type: NodeTypes.INTERPOLATION,\r\n      content: {\r\n        type: NodeTypes.SIMPLE_EXPRESSION,\r\n        isStatic: false,\r\n        content,\r\n      },\r\n    };\r\n  };\r\n  \r\n\r\n/**\r\n * ----------------解析文本节点parseText----------------\r\n */\r\n// 解析文本节点\r\n// 进来时是这样的\r\n// parse {{ element }}</div>\r\nconst parseText = (context) => {\r\n    // 两个结束标识\r\n    const endTokens = [\"<\", \"{{\"];\r\n    let endIndex = context.source.length;\r\n  \r\n    for (let i = 0; i < endTokens.length; i++) {\r\n      // 找结束标识\r\n      const index = context.source.indexOf(endTokens[i]);\r\n  \r\n      // 找最靠前的一个结束标识\r\n      if (index !== -1 && index < endIndex) {\r\n        endIndex = index;\r\n      }\r\n    }\r\n  \r\n    // 把结束标识前的所有内容分割出来\r\n    const content = parseTextData(context, endIndex);\r\n  \r\n    return {\r\n      type: NodeTypes.TEXT,\r\n      content,\r\n    };\r\n  };\r\n  \r\n\r\n\r\n/**\r\n * ----------------解析模板字符串用到的一些工具函数----------------\r\n */\r\n// 分割字符串\r\nconst advanceBy = (context, numberOfCharacters) => { //把已经解析完的字符串从source中切掉\r\n  const { source } = context;\r\n  context.source = source.slice(numberOfCharacters);\r\n};\r\n// 删除空格\r\nconst advanceSpaces = (context) => {\r\n  const spacesReg = /^[\\t\\r\\n\\f ]+/;\r\n  const match = spacesReg.exec(context.source);//exec()用于在一个字符串中执行匹配操作，如果匹配成功，它返回一个 数组，数组的第一个元素是匹配到的文本。如果匹配失败，返回null\r\n  if (match) {\r\n    advanceBy(context, match[0].length);\r\n  }\r\n};\r\n// 判断字符串是否以 xxx 开头\r\nconst startsWith = (source, searchString) => {\r\n  return source.startsWith(searchString);\r\n};\r\n// 判断字符串是否解析结束（为空或者是否以 </ 开头）\r\nconst isEnd = (context) => {\r\n  const s = context.source;\r\n  return !s || startsWith(s, \"</\");//source是空字符串？或者source 是以 </ 开头的？（说明遇到了闭合标签）\r\n};\r\n// 分割文本数据\r\nconst parseTextData = (context, length) => {\r\n  const rawText = context.source.slice(0, length);//slice(0, 9) 表示从索引 0 到 9（不包含 9）截取字符串。\r\n  advanceBy(context, length);\r\n  return rawText;\r\n};\r\n  \r\n\r\n","import { NodeTypes } from \"./ast\";\r\nimport { isArray, isString } from \"@vue/shared\";\r\n\r\n// 创建处理节点的上下文\r\n// 当对AST做各种处理的时候，需要一个上下文来：记录当前遍历到哪一个节点、保存各种转换规则、保存根节点引用、管理状态\r\nexport function createTransformContext( // 这个函数是用来“准备变换工作的环境的”\r\n    root,//根节点\r\n    //nodeTransforms：节点转换函数数组（处理 AST 中所有类型的节点）。里面放的是方法\r\n    //directiveTransforms：指令转换器对象（处理 v-if、v-model 等）。\r\n    { nodeTransforms = [], directiveTransforms = {} } \r\n  ) {\r\n    const context = {\r\n      // plugin\r\n      nodeTransforms,\r\n      directiveTransforms,\r\n  \r\n      // state\r\n      root,\r\n      parent: null,\r\n      currentNode: root,\r\n    };\r\n    return context;\r\n  }\r\n  \r\n\r\n// 转换节点\r\nexport function transform(root, options) {\r\n    const context = createTransformContext(root, options);\r\n    traverseNode(root, context);//遍历处理每个节点，这里的处理也就是上文提到过的转换插件transform plugins\r\n    createRootCodegen(root);//生成根节点的codegenNode\r\n}\r\n\r\n// 遍历并转换节点\r\nexport function traverseNode(node, context) {\r\n    context.currentNode = node;\r\n    // 获取转换插件序列\r\n    const { nodeTransforms } = context;\r\n    const exitFns = [];//初始化退出函数数组\r\n    // 通过插件依次对当前节点进行处理\r\n    for (let i = 0; i < nodeTransforms.length; i++) {\r\n      // 获取退出函数并缓存\r\n      const onExit = nodeTransforms[i](node, context);\r\n      if (onExit) {\r\n        if (isArray(onExit)) {\r\n          exitFns.push(...onExit);\r\n        } else {\r\n          exitFns.push(onExit);\r\n        }\r\n      }\r\n      if (!context.currentNode) {//检查当前节点是否被删除，有些 transform 可能“删除”当前节点（比如过滤注释节点），这时就不继续递归了。\r\n        return;\r\n      } else {\r\n        node = context.currentNode;\r\n      }\r\n    }\r\n    // 根据节点类型递归遍历子节点\r\n    switch (node.type) { //如果节点是一个容器节点（如元素、根节点），递归处理它的子节点。\r\n      case NodeTypes.ELEMENT:\r\n      case NodeTypes.ROOT:\r\n        traverseChildren(node, context);\r\n        break;\r\n  \r\n      case NodeTypes.INTERPOLATION:\r\n      case NodeTypes.TEXT:\r\n        // TODO：处理插值节点和文本节点\r\n        break;\r\n    }\r\n  \r\n    context.currentNode = node;//再次设置 currentNode（以防被 transform 修改）\r\n  \r\n    // 倒序执行退出函数，从子树回到当前节点\r\n    // 从叶子节点往根节点执行\r\n    let i = exitFns.length;\r\n    while (i--) {\r\n      exitFns[i]();\r\n    }\r\n    //所以的退出函数会在子节点处理完成之后倒序执行，实现后序处理逻辑\r\n  }\r\n  \r\n  \r\n// 遍历子节点\r\nexport function traverseChildren(parent, context) {\r\n    for (let i = 0; i < parent.children.length; i++) {\r\n      const child = parent.children[i];\r\n    // 如果子节点是字符串就直接跳过，因为在 AST 的语义中，字符串不是合法的子节点类型，它们只是临时的中间数据，编译器不会对它们做 transform 处理。\r\n      if (isString(child)) continue;\r\n      // 函数开头中 traverseChildren(parent, context)的parent是函数内部的一个局部变量，其他函数比如后面的traverseNode是访问不到这个parent的\r\n      context.parent = parent; // 在遍历子节点前，把当前正在遍历的“父节点”记录在上下文中，方便后续的转换逻辑（比如插值、表达式、标签等）知道自己的“父亲是谁”。\r\n      traverseNode(child, context);\r\n    }\r\n}\r\n  \r\n\r\n// 生成根节点的 codegenNode\r\nexport function createRootCodegen(root) {\r\n    const { children } = root;\r\n    if (children.length === 1) {\r\n      const child = children[0];\r\n      if (child.type === NodeTypes.ELEMENT && child.codegenNode) { //如果 child 是元素节点，并且它自己已经有 codegenNode\r\n        const codegenNode = child.codegenNode;// 说明这个元素节点已经转换完毕，可以直接拿来当作渲染起点：\r\n  \r\n        root.codegenNode = codegenNode;\r\n      } else {\r\n        root.codegenNode = child;\r\n      }\r\n    }\r\n  \r\n    // 源码中实现了多根节点的支持\r\n    // else if (children.length > 1) {}\r\n  }\r\n  ","/**\r\n * 编译模块用到的一些工具函数\r\n */\r\n\r\nimport { NodeTypes } from \"./ast\";\r\n\r\n// 判断传入节点是否是静态的简单表达式节\r\nexport const isStaticExp = (p) => {\r\n  return p.type === NodeTypes.SIMPLE_EXPRESSION && p.isStatic;\r\n};\r\n\r\n// 判断传入节点是否是文本节点或插值节点\r\nexport const isText = (node) => {\r\n  return node.type === NodeTypes.INTERPOLATION || node.type === NodeTypes.TEXT;\r\n};\r\n","import { isOn, PatchFlagNames } from \"@vue/shared\";\r\nimport {\r\n  createCallExpression,\r\n  createObjectExpression,\r\n  createObjectProperty,\r\n  createSimpleExpression,\r\n  createVNodeCall,\r\n  ElementTypes,\r\n  NodeTypes,\r\n} from \"../ast\";\r\nimport { isStaticExp } from \"../utils\";\r\nimport { PatchFlags } from \"@vue/shared\";\r\n// 负责创建 codegenNode 的函数，主要工作有处理 props、children、patchFlag然后最终返回一个codegenNode 对象\r\nexport const transformElement = (node, context) => { \r\n    return function postTransformElement() { //需要返回一个退出函数\r\n      node = context.currentNode;\r\n  \r\n      // 只对元素节点进行处理\r\n      if (node.type !== NodeTypes.ELEMENT) {\r\n        return;\r\n      }\r\n  \r\n      // 初始化如下变量\r\n      const { tag, props } = node;\r\n      const isComponent = node.tagType === ElementTypes.COMPONENT;\r\n  \r\n      let vnodeTag = `\"${tag}\"`;\r\n      let vnodeProps;\r\n      let vnodeChildren;\r\n      let vnodePatchFlag;\r\n      let patchFlag = 0;\r\n      let vnodeDynamicProps;\r\n      let dynamicPropNames;\r\n      let vnodeDirectives;\r\n  \r\n      // TODO 处理 props\r\n      // 获取属性解析结果\r\n      const propsBuildResult = buildProps(node, context);\r\n      vnodeProps = propsBuildResult.props;\r\n      patchFlag = propsBuildResult.patchFlag;\r\n      dynamicPropNames = propsBuildResult.dynamicPropNames;\r\n      vnodeDirectives = propsBuildResult.directives;\r\n\r\n\r\n      // TODO 处理 children\r\n    if (node.children.length > 0) {\r\n        if (node.children.length === 1) {\r\n          const child = node.children[0];\r\n          const type = child.type;\r\n        \r\n          // 分析是否存在动态文本子节点，插值表达式和复合文本节点\r\n          const hasDynamicTextChild =\r\n            type === NodeTypes.INTERPOLATION ||\r\n            type === NodeTypes.COMPOUND_EXPRESSION;\r\n        \r\n          // 有动态文本子节点则修改 patchFlag\r\n          if (hasDynamicTextChild) {\r\n            patchFlag |= PatchFlags.TEXT;\r\n          }\r\n      \r\n          // 获取 vnodeChildren\r\n          // type === NodeTypes.TEXT判断一个AST节点的类型是不是纯静态文本节点\r\n          if (hasDynamicTextChild || type === NodeTypes.TEXT) {\r\n            vnodeChildren = child;\r\n          } else {\r\n            vnodeChildren = node.children;\r\n          }\r\n        } else {\r\n          vnodeChildren = node.children;\r\n        }\r\n      }\r\n  \r\n\r\n      // TODO 处理 patchFlag\r\n\r\n\r\n      if (patchFlag !== 0) {\r\n        // patchFlag 为负数则说明不存在复合情况\r\n        if (patchFlag < 0) {\r\n          vnodePatchFlag = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`;\r\n        }\r\n      \r\n        // patchFlag 为正数说明可能存在复合情况，特殊处理\r\n        else {\r\n          const flagNames =\r\n            // 获取 PatchFlagNames 中所有的键名\r\n            Object.keys(PatchFlagNames)\r\n              // 全部转换为 Number 类型\r\n              .map(Number)\r\n              // 只保留 patchFlag 中存在的，并且值大于 0 的\r\n              .filter((n) => n > 0 && patchFlag & n)// patchFlag & n：当前 patchFlag 包含这个标志位（按位与成立）\r\n              // 将 patchFlag 数值转换成对应 patchFlag 名称\r\n              .map((n) => PatchFlagNames[n])\r\n              // 用逗号连接\r\n              .join(\", \");\r\n      \r\n          // 将上面的内容注释在 patchFlag 后面作为一个参考\r\n          vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;\r\n        }\r\n      \r\n        // TODO 处理动态属性名\r\n        if (dynamicPropNames && dynamicPropNames.length) {\r\n            vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);\r\n        }\r\n      }\r\n      \r\n      node.codegenNode = createVNodeCall(\r\n        node.type,\r\n        vnodeTag,\r\n        vnodeProps,\r\n        vnodeChildren,\r\n        vnodePatchFlag,\r\n        vnodeDynamicProps,\r\n        vnodeDirectives,\r\n        isComponent\r\n      );\r\n    };\r\n};\r\n  \r\n\r\n\r\n// 处理 props(这里跟源码的处理不同，源码的parse将所有属性都处理成了props，我们前面实现的parse分开处理props和directives)\r\n// 所以可以将directives也合并到props中，这样就可以一起处理了\r\nconst buildProps = (\r\n    node,\r\n    context,\r\n    props = [...node.props, ...node.directives]\r\n  ) => {\r\n    // 初始化一些变量\r\n    const isComponent = node.tagType === ElementTypes.COMPONENT;\r\n    let properties = []; // 遍历 props 生成的属性数组\r\n    const mergeArgs = []; // 用于存储需要合并到组件属性中的参数。比如在 Vue 中，可以通过 v-bind 或者简写 : 来绑定一个对象作为组件的属性，这些对象的属性需要被合并到最终的属性对象中。\r\n    const runtimeDirectives = []; // 用于存储运行时指令。在 Vue 中，指令（如 v-if, v-for, v-model 等）是特殊的标记，它们会在运行时对 DOM 元素进行额外的处理。这个数组将存储这些指令的相关信息。\r\n  \r\n    // 再初始化一些变量\r\n    let patchFlag = 0; // 用于标记属性是否发生了变化，以及变化的类型。用于 diff算法。\r\n    // 这两个布尔值用于标记节点是否有绑定的 class 或 style 属性。这些属性在 Vue 中是特殊的，因为它们可以绑定一个对象或者数组，而不是单个的字符串。\r\n    let hasClassBinding = false;\r\n    let hasStyleBinding = false;\r\n    let hasHydrationEventBinding = false; // 用于标记是否有事件绑定需要在 hydration（Vue 3 中的服务器端渲染过程中的客户端激活）阶段处理。\r\n    let hasDynamicKeys = false; // 用于标记是否有动态 key 属性，这对于列表渲染和虚拟 DOM 的高效更新非常重要。\r\n    const dynamicPropNames = []; // 用于存储动态绑定的属性名。\r\n  \r\n    // analyzePatchFlag 在下面的属性遍历中被用于处理内置指令，来为后面的 patchFlag 分析过程提供参照标准\r\n    const analyzePatchFlag = ({ key }) => {\r\n        // isStatic 会判断传入节点是否是静态的简单表达式节点 (SIMPLE_EXPRESSION)\r\n        if (isStaticExp(key)) {\r\n          const name = key.content;\r\n          // isOn 会判断传入属性是否是 onXxxx 事件注册\r\n          const isEventHandler = isOn(name);\r\n        \r\n          if (\r\n            !isComponent &&\r\n            isEventHandler && //当前属性是事件处理函数 是不是事件监听器 比如@click->onClick\r\n            //toLowerCase()大写字母转换为小写字母\r\n            name.toLowerCase() !== \"onclick\" // 特别排除掉 onClick，因为在 SSR 模式下，onClick 事件行为特殊（比如内联脚本攻击风险）。\r\n            // 源码这里还会忽略 v-model 双向绑定\r\n            // 源码这里还会忽略 onVnodeXXX hooks\r\n          ) {\r\n            hasHydrationEventBinding = true;// 标记当前 VNode 在 hydration 时需要附加事件\r\n          }\r\n      \r\n          // 源码在这里会忽略 cacheHandler 以及有静态值的属性\r\n      \r\n          // 这里根据属性的名称进行分析\r\n          if (name === \"class\") {\r\n            hasClassBinding = true;\r\n          } else if (name === \"style\") {\r\n            hasStyleBinding = true;\r\n          } else if (name !== \"key\" && !dynamicPropNames.includes(name)) { //收集“动态属性名”，但排除 key 属性和已经添加过的属性名\r\n            dynamicPropNames.push(name);\r\n          }\r\n      \r\n          // 将组件上绑定的类名以及样式视为动态属性\r\n          if (\r\n            isComponent &&\r\n            (name === \"class\" || name === \"style\") &&\r\n            !dynamicPropNames.includes(name)\r\n          ) {\r\n            dynamicPropNames.push(name);\r\n          }\r\n        } else {\r\n          // 属性名不是简单表达式 (SIMPLE_EXPRESSION) 的话\r\n          // 则视为有动态键名\r\n          hasDynamicKeys = true;\r\n        }\r\n    };\r\n\r\n    // 将静态属性筛选出来并封装成相应的节点\r\n    for (let i = 0; i < props.length; i++) {\r\n        const prop = props[i];\r\n        // 处理静态属性static attribute\r\n        if (prop.type === NodeTypes.ATTRIBUTE) {\r\n          const { name, value } = prop;\r\n          let valueNode = createSimpleExpression(value || \"\", true);\r\n      \r\n          properties.push(\r\n            createObjectProperty(createSimpleExpression(name, true), valueNode)\r\n          );\r\n        } else {\r\n          // TODO 处理指令directives\r\n          const { name, arg, exp } = prop;\r\n          const isVBind = name === \"bind\";\r\n          const isVOn = name === \"on\";\r\n                  \r\n          // 源码这里会跳过以下指令\r\n          // v-slot\r\n          // v-once/v-memo\r\n          // v-is/:is\r\n          // SSR 环境下的 v-on\r\n                  \r\n          // 处理无参数的 v-bind 以及 v-on（比如 v-bind=\"obj\"此时上面绑定的内容可以动态更换，有参数的情况是 v-bind:xxx=\"obj\"）\r\n          if (!arg && (isVBind || isVOn)) {\r\n          // 有动态的键\r\n            hasDynamicKeys = true;\r\n                  \r\n            // 有值的话，则进行处理\r\n            if (exp) {//  如果有表达式（例如 v-bind=\"obj\" 中的 obj），则说明需要合并。\r\n              if (properties.length) {// 如果前面已经积累了一些静态或普通 props（如 :id=\"foo\"、:class=\"bar\"），先将它们打包成一个对象表达式，加入合并参数中。然后清空 properties，准备下一个合并。\r\n                mergeArgs.push(createObjectExpression(properties));\r\n                properties = [];\r\n              }\r\n\r\n              if (isVBind) {\r\n                // 是 v-bind\r\n                mergeArgs.push(exp);\r\n              } else { \r\n                // 是 v-on\r\n                mergeArgs.push({\r\n                  type: NodeTypes.JS_CALL_EXPRESSION,\r\n                  arguments: [exp],\r\n                });\r\n              }\r\n            }\r\n            continue;\r\n          }\r\n\r\n          // 运行时指令处理\r\n          // context.directiveTransforms 是 Vue 编译器内部提供的一个 “内置指令转换器表”，是一个对象，键是指令名（不带v-），值是一个转换函数（也叫directiveTransform）\r\n          const directiveTransform = context.directiveTransforms[name];// 尝试获取这个指令名，（如 model、show）对应的内置指令处理函数。\r\n          if (directiveTransform) {\r\n            // 内置指令\r\n            // props: 静态属性节点数组（用于 patch diff 和 DOM 渲染）；needRuntime: 是否仍然需要在运行时处理（如 v-model 还需要动态绑定事件）。\r\n            const { props, needRuntime } = directiveTransform(prop, node, context);\r\n            // 每个属性都去执行一遍 analyzePatchFlag\r\n            props.forEach(analyzePatchFlag);\r\n            properties.push(...props);\r\n            if (needRuntime) {\r\n              runtimeDirectives.push(prop);\r\n            }\r\n          } else {\r\n            // 自定义指令\r\n            runtimeDirectives.push(prop);// 如果是自定义指令（如 v-focus, v-permission），Vue 编译器不懂，只能保留原样并标记它需要运行时处理。\r\n          }\r\n\r\n\r\n        }\r\n    }\r\n      \r\n  \r\n    // 合并参数\r\n    // 在这一步会根据参数不同进一步进行封装，mergeArgs 只会在处理无参数的 v-bind、v-on 时才会进行处理，因此这一步合并的其实就是 v-bind 和 v-on 。\r\n    let propsExpression = undefined; // propsExpression 是一个表达式，它代表了组件的属性（props）的最终形式。\r\n    // 如果有 v-bind\r\n    if (mergeArgs.length) {\r\n      // 如果有其他属性，那么将它们合并到 mergeArgs 中，因为最终的 propsExpression 是通过 mergeArgs 创建的。\r\n      if (properties.length) {\r\n        mergeArgs.push(createObjectExpression(properties));\r\n      }\r\n\r\n      if (mergeArgs.length > 1) {// 如果需要合并多个对象（mergeArgs.length > 1），就创建一个函数调用表达式,比如Object.assign({}, obj1, obj2, obj3)\r\n        propsExpression = createCallExpression(mergeArgs);\r\n      } else {\r\n        // 只有一个 v-bind,就直接使用，不需要合并\r\n        propsExpression = mergeArgs[0];\r\n      }\r\n    } else if (properties.length) { // 如果没有v-bind 等，只是普通静态属性，那就用 createObjectExpression(properties) 生成一个对象：\r\n      propsExpression = createObjectExpression(properties);\r\n    }\r\n\r\n\r\n  \r\n    // TODO 分析 patchFlag\r\n    if (hasDynamicKeys) { // 判断是不是有动态的Key\r\n        patchFlag |= PatchFlags.FULL_PROPS;// FULL_PROPS（全属性都需要 patch）。\r\n      } else {\r\n        if (hasClassBinding && !isComponent) {\r\n          patchFlag |= PatchFlags.CLASS;\r\n        }\r\n        if (hasStyleBinding && !isComponent) {\r\n          patchFlag |= PatchFlags.STYLE;\r\n        }\r\n        if (dynamicPropNames.length) {// 有指定属性变化\r\n          patchFlag |= PatchFlags.PROPS;\r\n        }\r\n        if (hasHydrationEventBinding) {\r\n          patchFlag |= PatchFlags.NEED_HYDRATION;\r\n        }\r\n    }\r\n      \r\n      // 这里在源码中还会考虑 ref 以及 vnodeHook\r\n    if (\r\n        (patchFlag === 0 || patchFlag === PatchFlags.NEED_HYDRATION) &&\r\n        runtimeDirectives.length > 0\r\n    ) {\r\n        patchFlag |= PatchFlags.NEED_PATCH;//Vue 为了确保指令如 v-show, v-model 这类运行时处理的逻辑能生效，即使这个节点看起来是“静态的”，也需要 patch 一次。 \r\n    }\r\n      \r\n    // TODO 规范化 props\r\n    if (propsExpression) {// 只有存在 propsExpression 才继续处理，propsExpression 是一个 AST 节点，表示组件的属性表达式。\r\n        switch (propsExpression.type) {\r\n          // 说明 props 中没有 v-bind，只需要处理动态的属性绑定\r\n          case NodeTypes.JS_OBJECT_EXPRESSION://JS对象表达式\r\n            let classKeyIndex = -1;\r\n            let styleKeyIndex = -1;\r\n            let hasDynamicKey = false;\r\n      \r\n            // 遍历所有 props，获取类名以及样式的索引\r\n            // 并判断是否有动态键名\r\n            for (let i = 0; i < propsExpression.properties.length; i++) {\r\n              const key = propsExpression.properties[i].key;\r\n              // 是静态键名\r\n              if (isStaticExp(key)) {\r\n                if (key.content === \"class\") {\r\n                  classKeyIndex = i;\r\n                } else if (key.content === \"style\") {\r\n                  styleKeyIndex = i;\r\n                }\r\n              }\r\n              // 是动态键名\r\n              else if (!key.isHandlerKey) {\r\n                hasDynamicKey = true;\r\n              }\r\n            }\r\n      \r\n            const classProp = propsExpression.properties[classKeyIndex];\r\n            const styleProp = propsExpression.properties[styleKeyIndex];\r\n      \r\n            // 没有动态键名\r\n            if (!hasDynamicKey) {\r\n              // 类名的值是动态的话则包装一下类名的值\r\n              if (classProp && !isStaticExp(classProp.value)) {\r\n                classProp.value = createCallExpression([classProp.value]);\r\n              }\r\n      \r\n              // 样式的值是动态的则包装一下样式的值\r\n              // styleprop表示 props 对象中是否存在 style 属性。<div :style=\"myStyle\" />会被转换成  style: myStyle，此时styleProp 就是这个对象属性节点\r\n              if (\r\n                styleProp &&\r\n                !isStaticExp(styleProp.value) &&\r\n                (hasStyleBinding ||\r\n                  styleProp.value.type === NodeTypes.JS_ARRAY_EXPRESSION)// 这一行，表示样式是数组形式的绑定，比如:style=\"[style1, style2]\"，这种情况 value 是一个数组表达式（JS_ARRAY_EXPRESSION），需要在运行时进行合并解析。\r\n              ) {\r\n                styleProp.value = createCallExpression([styleProp.value]);\r\n              }\r\n            }\r\n      \r\n            // 有动态键名则直接包装整个 propsExpression\r\n            else {\r\n              propsExpression = createCallExpression([propsExpression]);\r\n            }\r\n            break;\r\n      \r\n          // 合并属性，不需要处理\r\n          case NodeTypes.JS_CALL_EXPRESSION:\r\n            break;\r\n      \r\n          // 只有 v-bind 直接包装整个 propsExpression\r\n          default:\r\n            propsExpression = createCallExpression([\r\n              createCallExpression([propsExpression]),\r\n            ]);\r\n            break;\r\n        }\r\n      }\r\n    // 返回结果\r\n    return {\r\n        props: propsExpression,\r\n        directives: runtimeDirectives,\r\n        patchFlag,\r\n        dynamicPropNames,\r\n    };\r\n};\r\n  \r\n\r\n\r\n// 遍历所有节点并转换成数组结构的字符串返回\r\nconst stringifyDynamicPropNames = (props) => {\r\n    let propsNamesString = \"[\";\r\n    for (let i = 0, l = props.length; i < l; i++) {\r\n      propsNamesString += JSON.stringify(props[i]);\r\n      if (i < l - 1) propsNamesString += \",\";\r\n    }\r\n    return propsNamesString + \"]\";\r\n};\r\n  \r\n\r\n","import { NodeTypes } from \"../ast\";\r\nimport { isText } from \"../utils\";\r\n\r\n// 处理组合表达式\r\nexport const transformText = (node) => {\r\n    // 只有元素节点和根节点需要处理\r\n    if (node.type === NodeTypes.ROOT || node.type === NodeTypes.ELEMENT) {\r\n      return function postTransformText() {\r\n        console.log(\"调用transformText方法处理组合表达式，当前节点为\", node);\r\n        const children = node.children;\r\n        let currentContainer = undefined;\r\n        let hasText = false;\r\n  \r\n        // 遍历查找文本/插值表达式节点\r\n        for (let i = 0; i < children.length; i++) {\r\n          const child = children[i];\r\n          // 找到则将 hasText 置为 true 并查找后面的节点\r\n          if (isText(child)) {\r\n            hasText = true;\r\n            // 查找后面的节点\r\n            for (let j = i + 1; j < children.length; j++) {\r\n              const next = children[j];\r\n              // 找到了则进行合并\r\n              if (isText(next)) {\r\n                if (!currentContainer) {\r\n                  currentContainer = children[i] = {\r\n                    type: NodeTypes.COMPOUND_EXPRESSION,\r\n                    children: [child],\r\n                  };\r\n                }\r\n  \r\n                // 合并相邻文本/插值表达式节点到 currentContainer 内，currentContainer 只是children[i]的一个引用，改变currentContainer的值，children[i]也会改变\r\n                currentContainer.children.push(next);\r\n                children.splice(j, 1);\r\n                j--;\r\n              } else {\r\n                // 没找到就直接退出\r\n                currentContainer = undefined;\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        }\r\n        console.log(\"处理组合表达式后的结果currentContainer\", currentContainer);\r\n      };\r\n    }\r\n};\r\n  \r\n","import { capitalize, toHandlerKey } from \"@vue/shared\";\r\nimport {\r\n  createObjectProperty,\r\n  createSimpleExpression,\r\n  NodeTypes,\r\n} from \"../ast\";\r\n//v-on 需要驼峰化事件监听、处理事件监听缓存、应用拓展插件等\r\n//简化之后的transformOn要做的事情非常简单，只需要驼峰化事件监听，然后包装成 JS_PROPERTY 类型的对象返回即可\r\n\r\n// 处理 v-on 指令\r\nexport const transformOn = (dir) => { // dir是一个描述v-on指令的节点对象\r\n    const { arg } = dir;\r\n  \r\n    // 驼峰化\r\n    let eventName;\r\n    if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {\r\n      if (arg.isStatic) {\r\n        const rawName = arg.content; //获取事件名字符串，如 \"click\"。\r\n        eventName = createSimpleExpression(\r\n          toHandlerKey(capitalize(rawName)),//capitalize(rawName)：把事件名首字母大写;  toHandlerKey(\"Click\")：添加 on 前缀;  createSimpleExpression(\"onClick\", true)：包装成一个静态表达式节点。  \r\n          true\r\n        );\r\n      }\r\n      // 源码在这里将动态的事件名处理成组合表达式\r\n    } else {\r\n      eventName = arg;\r\n    }\r\n  \r\n    // 处理表达式\r\n    let exp = dir.exp;// 获取指令绑定的表达式（handler 函数名）：例子：@click=\"doSomething\" → exp.content === \"doSomething\"\r\n    if (exp && !exp.content.trim()) { // 如果exp存在但是空字符串\r\n      exp = undefined;\r\n    }\r\n    // 源码在这里会处理事件缓存\r\n    // 源码在这里会处理外部插件 extended compiler augmentor\r\n  \r\n    // 包装并返回 JS_PROPERTY 节点\r\n    const ret = {\r\n      props: [\r\n        createObjectProperty( //生成形如 { key: value } 的 AST 结构。\r\n          eventName,\r\n          exp || createSimpleExpression(\"() => {}\", false) //exp：处理函数表达式，如 \"handleClick\"；如果为空就用 () => {} 兜底（避免运行时报错）\r\n        ),\r\n      ],\r\n    };\r\n    return ret;\r\n};\r\n  \r\n","import {\r\n    createObjectProperty,\r\n    createSimpleExpression,\r\n    NodeTypes,\r\n  } from \"../ast\";\r\n// 处理 v-bind 指令\r\nexport const transformBind = (dir) => {\r\n    // dir 是指令对象，包含如 exp（表达式）和 arg（属性名）等信息。v-bind:class=\"myClass\" 中：dir.arg.content === \"class\";dir.exp.content === \"myClass\"\r\n    const { exp } = dir;\r\n    const arg = dir.arg;\r\n  \r\n    // 容错处理，如果为空则输出一个空字符串\r\n    // 因为 arg 是一个简单的表达式，并且是动态的（因为它的值可能会改变），所以 transformBind 函数会在 myClass 前后添加条件运算符||，\r\n    // 以确保如果 myClass 的值为 undefined 或''（空字符串），它将返回一个空字符串而不是错误。（即容错处理）\r\n\r\n    if (arg.type !== NodeTypes.SIMPLE_EXPRESSION) {\r\n      arg.children.unshift(\"(\");//动态 key 的安全处理：将表达式包装为 (foo) || \"\"，防止 foo 为 undefined 时报错。\r\n      arg.children.push(') || \"\"');\r\n    } else if (!arg.isStatic) {\r\n      arg.content = `${arg.content} || \"\"`;\r\n    }\r\n  \r\n    // 包装并返回 JS_PROPERTY 节点\r\n    if (\r\n      !exp ||\r\n      (exp.type === NodeTypes.SIMPLE_EXPRESSION && !exp.content.trim())\r\n    ) {\r\n      return {\r\n        props: [createObjectProperty(arg, createSimpleExpression(\"\", true))],// createSimpleExpression(\"\", true) 表示一个静态空字符串表达式。\r\n      };\r\n    }\r\n  \r\n    const ret = {\r\n      props: [createObjectProperty(arg, exp)],\r\n    };\r\n  \r\n    return ret;\r\n    // 最终，transformBind 函数会返回一个新的对象，它包含了一个属性，这个属性的键是带有前缀的属性名（.class），值是我们的表达式（myClass）。（即包装节点）\r\n\r\n  };\r\n","import { isObject } from \"@vue/shared\";\r\nimport { NodeTypes } from \"./ast\";\r\n// codegen 代码生成\r\nexport const generate = (ast) => {\r\n    // 获取上下文（包含生成代码所需的状态和工具函数）\r\n    const context = createCodegenContext();\r\n    // push用于添加代码到上下文中，indent和deindent用于增加或减少代码的缩进级别。\r\n    const { push, indent, deindent } = context; //解构出三个函数\r\n    //context.code是字符串缓冲区，用于收集最终形成的js渲染函数代码\r\n  \r\n    indent();// 增加当前代码缩进层级，使输出的代码格式化美观。\r\n\r\n    // vue编译器的目标，是把我的模版编译成js渲染函数->  return h(\"div\", null, ctx.count)\r\n    // 但是但 Vue 不想手动在每个地方都加 ctx.，太麻烦、代码冗余。因此它用了 JavaScript 的 with 语句：\r\n    // with (ctx) { ... } 表示，把 ctx 这个对象的属性当作局部变量来用。\r\n    // 如果你写 with(ctx){console.log(count)}，虽然count没有声明，但是JS会在ctx中查找属性，等价于console.log(ctx.count);\r\n\r\n\r\n    push(\"with (ctx) {\"); // with语句用于确保ctx中的属性和方法可以在代码块内部直接访问，用于后面的new Function生成代码(因此此时生成的是字符串，里面的h函数、渲染的值以及函数等都需要传入)\r\n    indent(); // 再次缩进，进入 with 语句内部\r\n  \r\n    push(\"return function render(){return \");\r\n    if (ast.codegenNode) {\r\n      genNode(ast.codegenNode, context); // 递归生成代码\r\n    } else {\r\n      push(\"null\");\r\n    }\r\n  \r\n    deindent();\r\n    push(\"}}\");\r\n  \r\n    return {\r\n      ast,\r\n      code: context.code,\r\n    };\r\n  };\r\n  \r\n\r\n\r\n// 获取上下文\r\nconst createCodegenContext = () => {\r\n    const context = {\r\n      // state\r\n      code: \"\", // 目标代码   字符串，储存了最终生成的代码内容\r\n      indentLevel: 0, // 缩进等级\r\n  \r\n      // method\r\n      push(code) { // 追加代码片段\r\n        context.code += code;\r\n      },\r\n      indent() { // 用于增加缩进级别，表示进入一个新的代码块。作用是调用 newline 函数，传入增加后的缩进等级。\r\n        newline(++context.indentLevel);\r\n      },\r\n      deindent(witoutNewLine = false) {// witoutNewLine 为 false（默认），会调用 newline 方法，先减小缩进，再添加换行符。\r\n        if (witoutNewLine) { // witoutNewLine 为 true，则只减小缩进，而不会添加换行符。\r\n          --context.indentLevel;\r\n        } else {\r\n          newline(--context.indentLevel);\r\n        }\r\n      },\r\n      newline() { // newline() 方法调用时，实际上是通过调用 newline(context.indentLevel)，将当前的 indentLevel（缩进级别）传递给局部的 newline(n) 函数。\r\n        newline(context.indentLevel);// 这一步的目的是封装 newline(n)，方便后续使用，只需要调用 newline() 就能自动传递 indentLevel。\r\n      },\r\n    };\r\n    function newline(n) {\r\n      context.push(\"\\n\" + \"  \".repeat(n));// \" \".repeat(n) 会生成 n 个空格\r\n    }\r\n    return context;\r\n};\r\n\r\n\r\n\r\n// 生成代码\r\nconst genNode = (node, context) => {\r\n    // 如果是字符串就直接 push\r\n    if (typeof node === \"string\") {\r\n      context.push(node);\r\n      return;\r\n    }\r\n  \r\n    switch (node.type) {\r\n      case NodeTypes.ELEMENT:\r\n        genElement(node, context);\r\n        break;\r\n      case NodeTypes.TEXT:\r\n      case NodeTypes.INTERPOLATION:\r\n        genTextData(node, context);\r\n        break;\r\n      case NodeTypes.COMPOUND_EXPRESSION:\r\n        genCompoundExpression(node, context);\r\n        break;\r\n    }\r\n};\r\n  \r\n\r\n// 生成元素节点\r\nconst genElement = (node, context) => {\r\n    const { push, deindent } = context;\r\n    const { tag, children, props } = node;\r\n  \r\n    // tag\r\n    push(`h(${tag}, `);// 用来生成虚拟 DOM 节点的 h 函数调用。虚拟 DOM 中的元素通常通过 h(tag, props, children) 来创建。\r\n  \r\n    // props\r\n    if (props) {\r\n      genProps(props.properties, context);\r\n    } else {\r\n      push(\"null, \");// 表示没有子节点\r\n    }\r\n  \r\n    // children\r\n    if (children) {\r\n      genChildren(children, context);\r\n    } else {\r\n      push(\"null\");\r\n    }\r\n  \r\n    deindent();\r\n    push(\")\");\r\n};\r\n\r\n\r\n// genProps要做的就是获取节点中的属性数据，并拼接成一个对象的样子push进目标代码\r\nconst genProps = (props, context) => {\r\n    const { push } = context;\r\n  \r\n    if (!props.length) {\r\n      push(\"{}\");\r\n      return;\r\n    }\r\n  \r\n    push(\"{ \");\r\n    for (let i = 0; i < props.length; i++) {\r\n      // 遍历每个 prop 对象，获取其中的 key 节点和 value 节点\r\n      const prop = props[i];\r\n      const key = prop ? prop.key : \"\";\r\n      const value = prop ? prop.value : prop;\r\n  \r\n      if (key) {\r\n        // key\r\n        genPropKey(key, context);\r\n        // value\r\n        genPropValue(value, context);\r\n      } else {\r\n        // 如果 key 不存在就说明是一个 v-bind\r\n        // ↑当 Vue 处理 v-bind 时，会把属性名作为一个动态的表达式来处理，而不是一个普通的字符串常量。所以，通常在编译过程中，当遇到没有静态 key 的情况时，就可以推测出这是一个 v-bind 的动态属性。\r\n        const { content, isStatic } = value;\r\n        const contentStr = JSON.stringify(content);\r\n        push(`${contentStr}: ${isStatic ? contentStr : content}`);\r\n      }\r\n  \r\n      if (i < props.length - 1) {\r\n        push(\", \");\r\n      }\r\n    }\r\n    push(\" }, \");\r\n  };\r\n  \r\n  // 生成键\r\n  const genPropKey = (node, context) => {\r\n    const { push } = context;\r\n    const { isStatic, content } = node;\r\n    push(isStatic ? JSON.stringify(content) : content);\r\n    push(\": \");\r\n  };\r\n  \r\n  // 生成值\r\n  const genPropValue = (node, context) => {\r\n    const { push } = context;\r\n    const { isStatic, content } = node;\r\n    push(isStatic ? JSON.stringify(content.content) : JSON.stringify(content));\r\n};\r\n  \r\n  \r\n// 生成子节点\r\nconst genChildren = (children, context) => {\r\n    const { push, indent } = context;\r\n  \r\n    push(\"[\");\r\n    indent();\r\n  \r\n    // 单独处理 COMPOUND_EXPRESSION\r\n    if (children.type === NodeTypes.COMPOUND_EXPRESSION) {\r\n      genCompoundExpression(children, context);\r\n    }\r\n  \r\n    // 单独处理 TEXT\r\n    else if (isObject(children) && children.type === NodeTypes.TEXT) {\r\n      genNode(children, context);\r\n    }\r\n  \r\n    // 其余节点直接递归\r\n    else {\r\n      for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        genNode(child.codegenNode || child.children, context);\r\n        push(\", \");\r\n      }\r\n    }\r\n  \r\n    push(\"]\");\r\n};\r\n\r\n\r\n// 生成文本节点和插值表达式节点\r\nconst genTextData = (node, context) => {\r\n    const { push } = context;\r\n    const { type, content } = node;\r\n  \r\n    // 如果是文本节点直接拿出 content\r\n    // 如果是插值表达式需要拿出 content.content，因为插值表达式节点在vue中是一个嵌套结构\r\n    const textContent =\r\n      type === NodeTypes.TEXT\r\n        ? JSON.stringify(content)\r\n        : NodeTypes.INTERPOLATION\r\n        ? content.content\r\n        : \"\";\r\n  \r\n    if (type === NodeTypes.TEXT) {\r\n      push(textContent);\r\n    }\r\n    if (type === NodeTypes.INTERPOLATION) {\r\n      push(\"`${\");\r\n      push(`${textContent}`);\r\n      push(\"}`\");\r\n    }\r\n};\r\n  \r\n// 生成复合表达式\r\nconst genCompoundExpression = (node, context) => {\r\n    const { push } = context;\r\n    for (let i = 0; i < node.children.length; i++) {\r\n      const child = node.children[i];\r\n      if (typeof child === \"string\") {\r\n        push(child);\r\n      } else {\r\n        genNode(child, context);\r\n      }\r\n  \r\n      if (i !== node.children.length - 1) {\r\n        push(\", \");\r\n      }\r\n    }\r\n};\r\n  \r\n\r\n  \r\n","import { extend, isString } from \"@vue/shared\";\r\nimport { baseParse } from \"./parse\";\r\nimport { transform } from \"./transform\";\r\nimport { transformElement } from \"./transforms/transformElement\";\r\nimport { transformText } from \"./transforms/transformText\";\r\nimport { transformOn } from \"./transforms/vOn\";\r\nimport { transformBind } from \"./transforms/vBind\";\r\nimport { generate } from \"./codegen\";\r\n\r\nexport const getBaseTransformPreset: () => [any[], {}] = () => {\r\n  // 插件预设\r\n  return [\r\n    [transformElement, transformText],\r\n    {\r\n      on: transformOn,\r\n      bind: transformBind,\r\n    },\r\n  ];\r\n};\r\n\r\n// 完整编译过程：template -> ast -> codegen -> render\r\nexport const baseCompile = (template, options: any = {}) => {\r\n  // 第一步：将模板字符串转换成AST\r\n  const ast = isString(template) ? baseParse(template) : template;\r\n  // 第二步：AST加工\r\n  const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();\r\n  transform(\r\n    ast,\r\n    extend({}, options, {\r\n      nodeTransforms: [...nodeTransforms, ...(options.nodeTransforms || [])],\r\n      directiveTransforms: extend(\r\n        {},\r\n        directiveTransforms,\r\n        options.directiveTransforms || {} // user transforms\r\n      ),\r\n    })\r\n  );\r\n  // 第三步：将AST转换成渲染函数，最终得到一个render渲染函数\r\n  return generate(ast);\r\n};\r\n"],"names":["isString","isVoidTag","isHTMLTag","isArray","PatchFlagNames","isOn","toHandlerKey","capitalize","isObject","extend"],"mappings":"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"}